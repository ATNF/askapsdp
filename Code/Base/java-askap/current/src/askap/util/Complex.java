// Copyright (C)1997  CSIRO Australia Telescope National Facility
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public License
// as published by the Free Software Foundation; either version 2 
// of the License, or (at your option) any later version. 
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of 
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
// GNU Library General Public License for more details. 
// 
// A copy of the GNU Library General Public License is available at: 
// http://wwwatoms.atnf.csiro.au/doc/gnu/GLGPL.htm 
// or, write to the Free Software Foundation, Inc., 59 Temple Place, 
// Suite 330, Boston, MA  02111-1307  USA 

package askap.util;

import java.io.*;

/**
 * Class representing complex data values. Each part of the complex number is
 * represented as a double float.
 * 
 * <p>
 * The string representation of a complex number is two double float numbers,
 * seperated by a comma. No whitespace is present in string representations
 * generated by the class. In string representations accepted by the class,
 * whitespace at the start or end of the string, or either side of the comma are
 * ignored.
 * 
 * @author Sugath Mudali
 * @author David G Loone
 * 
 * @version $Id: Complex.java,v 1.10 2004/09/07 05:31:50 bro764 Exp $
 */
public class Complex implements Cloneable, Serializable {
    private static final long serialVersionUID = 1L;

    /**
     * The real part.
     */
    protected double itsReal;

    /**
     * The imaginary part.
     */
    protected double itsImag;

    /**
     * Default constructor.
     */
    public static Complex factory() {
        return new Complex();
    }

    /**
     * Default constructor.
     */
    public Complex() {
        itsReal = 0;
        itsImag = 0;
    }

    /**
     * The contents of both real and imaginary parts are set.
     * 
     * @param r
     *            The real part.
     * 
     * @param i
     *            The imaginary part.
     */
    public static Complex factory(double r, double i) {
        return new Complex(r, i);
    }

    /**
     * The contents of both real and imaginary parts are set.
     * 
     * @param r
     *            The real part.
     * 
     * @param i
     *            The imaginary part.
     */
    private Complex(double r, double i) {
        itsReal = r;
        itsImag = i;
    }

    /**
     * Create a <code>Complex</code> object from an existing
     * <code>Complex</code> object.
     * 
     * @param c
     *            Another <code>Complex</code> object to copy the value from.
     */
    public static Complex factory(Complex c) {
        return new Complex(c);
    }

    /**
     * Create a <code>Complex</code> object from an existing
     * <code>Complex</code> object.
     * 
     * @param c
     *            Another <code>Complex</code> object to copy the value from.
     */
    private Complex(Complex c) {
        itsReal = c.itsReal;
        itsImag = c.itsImag;
    }

    /**
     * Create a complex object from a string representation.
     * 
     * @param str
     *            A <code>String</code> representation of a complex number.
     * 
     * @exception NumberFormatException
     *                Thrown when a <code>String</code> does not contain a valid
     *                string representation of a complex number.
     */
    public static Complex factory(String str) throws NumberFormatException {
        return new Complex(str);
    }

    /**
     * Create a complex object from a string representation.
     * 
     * @param str
     *            A <code>String</code> representation of a complex number.
     * 
     * @exception NumberFormatException
     *                Thrown when a <code>String</code> does not contain a valid
     *                string representation of a complex number.
     */
    private Complex(String str) throws NumberFormatException {
        // Compute the location of ',' in the String object. If not found
        // then marker is set to -1. Using this negative value to create a
        // double value would cause an exception.
        int marker = str.indexOf(',');
        try {
            // First part up to the marker (not including).
            itsReal = Double.valueOf(str.substring(0, marker)).doubleValue();
            // The rest of the string from marker on wards.
            itsImag = Double.valueOf(str.substring(marker + 1, str.length()))
                    .doubleValue();
        } catch (Exception e) {
            throw new NumberFormatException(str);
        }
    }

    /**
     * Clone the object.
     * 
     * @return A new object identical to this one.
     */
    public synchronized Object clone() {
        // The clone to return.
        Complex clone = null;

        // Make the clone.
        try {
            clone = (Complex) super.clone();
        } catch (CloneNotSupportedException e) {
            // Should never happen.
            assert (false);
        }
        clone.itsReal = itsReal;
        clone.itsImag = itsImag;

        // Return the clone.
        return clone;
    }

    /**
     * Tests for equivalency.
     * 
     * <p>
     * All the usual warnings about comparing equality of floating numbers
     * apply.
     * 
     * @param o
     *            The complex number to test for equivalancy against.
     * 
     * @return Boolean <code>true</code> if <code>a</code> is equal to this
     *         complex number, <code>false</code> otherwise.
     */
    public synchronized boolean equiv(Object o) {
        // The value to return.
        boolean isEquiv = false;
        // Local version of o.
        Complex o1;

        // Prerequisites.
        if ((o != null) && (o.getClass() == getClass())) {
            o1 = (Complex) o;
            // Is equal if same object.
            if (equals(o1)) {
                isEquiv = true;
            } else {
                // Test the attributes.
                isEquiv = ((o1.itsReal == itsReal) && (o1.itsImag == itsImag));
            }
        }

        return isEquiv;
    }

    /**
     * Test for not-a-number. This complex number is not-a-number if either its
     * real or imaginary components are not-a-number.
     * 
     * @return Boolean <code>true</code> if this complex number is not-a-number,
     *         <code>false</code> otherwise.
     */
    public synchronized boolean isNaN() {
        return ((new Double(itsReal)).isNaN() || (new Double(itsImag).isNaN()));
    }

    /**
     * Test for infinity. This complex number is infinite if either its real or
     * imaginary components is infinite.
     * 
     * @return Boolean <code>true</code> if this complex number is infinite,
     *         <code>false</code> otherwise.
     */
    public synchronized boolean isInfinite() {
        return ((new Double(itsReal)).isInfinite() || (new Double(itsImag))
                .isInfinite());
    }

    /**
     * Sets the real part of this complex number.
     * 
     * @param realPart
     *            The real part.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex setReal(double realPart) {
        itsReal = realPart;

        return this;
    }

    /**
     * Returns the real part of this complex number.
     * 
     * @return The real part.
     */
    public synchronized double getReal() {
        return itsReal;
    }

    /**
     * Sets the imaginary part of this complex number.
     * 
     * @param imagPart
     *            The imaginary part.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex setImag(double imagPart) {
        itsImag = imagPart;

        return this;
    }

    /**
     * Returns the imaginary part of this complex number.
     * 
     * @return The imaginary part.
     */
    public synchronized double getImag() {
        return itsImag;
    }

    /**
     * Returns the polar radius of this complex number.
     * 
     * @return The polar radius of this complex number.
     */
    public synchronized double getRadius() {
        return Math.sqrt(Math.pow(itsReal, 2) + Math.pow(itsImag, 2));
    }

    /**
     * Sets the polar angle of this complex number, keeping the polar radius
     * constant.
     * 
     * @param a
     *            The new polar angle.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex setAngle(double a) {
        // The new angle as its wrapper object.
        Double aObj = new Double(a);
        // The current radius (to be maintained).
        double r;

        // Check some special cases.
        if (aObj.isInfinite()) {
            itsReal = Double.NaN;
            itsImag = Double.NaN;
        } else if (aObj.isNaN()) {
            itsReal = Double.NaN;
            itsImag = Double.NaN;
        } else {
            // Calculate the current radius.
            r = getRadius();

            // Claculate the new real and imaginary parts from the current
            // radius and the new angle.
            itsReal = r * Math.cos(a);
            itsImag = r * Math.sin(a);
        }

        return this;
    }

    /**
     * Returns a <code>String</code> representation of this complex number.
     * Example: 12.3,12.4 or -12.3,-12.4.
     * 
     * @return The string representation of this complex number.
     */
    public synchronized String toString() {
        return ((new Double(itsReal)).toString() + "," + (new Double(itsImag))
                .toString());
    }

    /**
     * Negate this complex number.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex negate() {
        // Simply negate both real and imaginary components.
        itsReal = -itsReal;
        itsImag = -itsImag;

        return this;
    }

    /**
     * Calculates the sum of this complex number and another.
     * 
     * @param x
     *            The complex number to add to this one.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex add(Complex x) {
        // Simply add real and imaginary components.
        itsReal = itsReal + x.itsReal;
        itsImag = itsImag + x.itsImag;

        return this;
    }

    /**
     * Adds to the real part of this complex number.
     * 
     * @param realInc
     *            The quantity to add to the real part.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex addReal(double realInc) {
        // Just add the parameter to the real component.
        itsReal = itsReal + realInc;

        return this;
    }

    /**
     * Adds to the imaginary part of this complex number.
     * 
     * @param imagInc
     *            The quantity to add to the imaginary part.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex addImag(double imagInc) {
        // Just add the parameter to the imaginary component.
        itsImag = itsImag + imagInc;

        return this;
    }

    /**
     * Calculates the product of this complex number with a scalar.
     * 
     * @param r
     *            The scalar number to multiply by.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex multiply(double r) {
        // Multiply both real and imaginary parts by r.
        itsReal = itsReal * r;
        itsImag = itsImag * r;

        return this;
    }

    /**
     * Multiplies this complex number by another.
     * 
     * <p>
     * The first multiplicand is this number. The second multiplicand is the
     * complex number parameter.
     * 
     * @param x
     *            The second multiplicand.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex multiply(Complex x) {
        // Temporary storage for the new real component.
        double newReal;
        // Temporary storage for the new imaginary component.
        double newImag;

        // Calculate the product. Save the new new real and imaginary
        // components somewhere else so that they don't break the
        // calculations
        newReal = this.itsReal * x.itsReal - this.itsImag * x.itsImag;
        newImag = this.itsImag * x.itsReal + this.itsReal * x.itsImag;
        this.itsReal = newReal;
        this.itsImag = newImag;

        return this;
    }

    /**
     * Divides this complex number by a scalar.
     * 
     * @param r
     *            The scalar number to be the denominator.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex divide(double r) {
        // Divide real and imaginary components by r.
        itsReal = itsReal / r;
        itsImag = itsImag / r;

        return this;
    }

    /**
     * Divides this complex number by another.
     * 
     * <p>
     * The numerator is this number. The denominator is the complex number
     * parameter.
     * 
     * @param x
     *            The denominator.
     * 
     * @return A reference to this object.
     */
    public synchronized Complex divide(Complex x) {
        // The denominator for both real and imaginary results.
        double denominator;
        // An intermediate value.
        double t;
        // Temporary storage for the new real component.
        double newReal;
        // Temporary storage for the new imaginary component.
        double newImag;

        // Do differently depending on zone. Put real and imaginary
        // result components in temporary variables so that they don't
        // corrupt the calculation.
        if (Math.abs(x.itsReal) == Math.abs(x.itsImag)) {
            denominator = x.itsReal + x.itsImag;
            newReal = (itsReal + itsImag) / denominator;
            newImag = (itsImag - itsReal) / denominator;
        } else if (Math.abs(x.itsReal) < Math.abs(x.itsImag)) {
            t = x.itsReal / x.itsImag;
            denominator = x.itsReal * t + x.itsImag;
            newReal = (itsReal * t + itsImag) / denominator;
            newImag = (itsImag * t - itsReal) / denominator;
        } else {
            t = x.itsImag / x.itsReal;
            denominator = x.itsReal + x.itsImag * t;
            newReal = (itsReal + itsImag * t) / denominator;
            newImag = (itsImag - itsReal * t) / denominator;
        }

        itsReal = newReal;
        itsImag = newImag;

        return this;
    }

}
