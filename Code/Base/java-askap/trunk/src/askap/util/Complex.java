// Copyright (C)1997  CSIRO Australia Telescope National Facility
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public License
// as published by the Free Software Foundation; either version 2 
// of the License, or (at your option) any later version. 
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of 
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
// GNU Library General Public License for more details. 
// 
// A copy of the GNU Library General Public License is available at: 
// http://wwwatoms.atnf.csiro.au/doc/gnu/GLGPL.htm 
// or, write to the Free Software Foundation, Inc., 59 Temple Place, 
// Suite 330, Boston, MA  02111-1307  USA 

package askap.util;

import java.io.*;

/**
 * Class representing complex data values.
 * Each part of the complex number is represented as a double float.
 *
 * <p>
 * The string representation of a complex number is two double float
 * numbers, seperated by a comma. No whitespace is present in string
 * representations generated by the class. In string representations
 * accepted by the class, whitespace at the start or end of the string,
 * or either side of the comma are ignored.
 *
 * @author Sugath Mudali
 * @author David G Loone
 *
 * @version $Id: Complex.java,v 1.10 2004/09/07 05:31:50 bro764 Exp $
 */
public
class Complex
implements
  Cloneable,
  Serializable
{

  /**
   * The RCS id.
   */
  final public static
  String RCSID = "$Id: Complex.java,v 1.10 2004/09/07 05:31:50 bro764 Exp $";

  /**
   * The real part.
   */
  protected
  double itsReal;

  /**
   * The imaginary part.
   */
  protected
  double itsImag;

  /**
   * Default constructor.
   */
  public static
  Complex
  factory()
  {
    return new Complex();
  }

  /**
   * Default constructor.
   */
  public
  Complex()
  {
    itsReal = 0;
    itsImag = 0;
  }

  /**
   * The contents of both real and imaginary parts are set.
   *
   * @param r
   *  The real part.
   *
   * @param i
   *  The imaginary part.
   */
  public static
  Complex
  factory(
    double r,
    double i
  )
  {
    return new Complex(r,i);
  }

  /**
   * The contents of both real and imaginary parts are set.
   *
   * @param r
   *  The real part.
   *
   * @param i
   *  The imaginary part.
   */
  private
  Complex(
    double r,
    double i
  )
  {
    itsReal = r;
    itsImag = i;
  }

  /**
   * Create a <code>Complex</code> object from an existing
   *  <code>Complex</code> object.
   *
   * @param c
   *  Another <code>Complex</code> object to copy the value from.
   */
  public static
  Complex
  factory(
    Complex c
  )
  {
    return new Complex(c);
  }

  /**
   * Create a <code>Complex</code> object from an existing
   *  <code>Complex</code> object.
   *
   * @param c
   *  Another <code>Complex</code> object to copy the value from.
   */
  private
  Complex(
    Complex c
  )
  {
    itsReal = c.itsReal;
    itsImag = c.itsImag;
  }

  /**
   * Create a complex object from a string representation.
   *
   * @param str
   *  A <code>String</code> representation of a complex number.
   *
   * @exception NumberFormatException
   *  Thrown when a <code>String</code> does not contain a valid
   *  string representation of a complex number.
   */
  public static
  Complex
  factory(
    String str
  )
  throws
    NumberFormatException
  {
    return new Complex(str);
  }

  /**
   * Create a complex object from a string representation.
   *
   * @param str
   *  A <code>String</code> representation of a complex number.
   *
   * @exception NumberFormatException
   *  Thrown when a <code>String</code> does not contain a valid
   *  string representation of a complex number.
   */
  private
  Complex(
    String str
  )
  throws
    NumberFormatException
  {
    // Compute the location of ',' in the String object. If not found
    // then marker is set to -1. Using this negative value to create a
    // double value would cause an exception.
    int marker = str.indexOf(',');
    try {
      // First part up to the marker (not including).
      itsReal = Double.valueOf(str.substring(0, marker)).doubleValue();
      // The rest of the string from marker on wards.
      itsImag = Double.valueOf(str.substring(marker + 1,
          str.length())).doubleValue();
    }
    catch(Exception e) {
      throw new NumberFormatException(str);
    }      
  }

  /**
   * Clone the object.
   *
   * @return
   *  A new object identical to this one.
   */
  public synchronized
  Object
  clone()
  {
    // The clone to return.
    Complex clone = null;

    // Make the clone.
    try {
      clone = (Complex)super.clone();
    }
    catch(CloneNotSupportedException e) {
      // Should never happen.
      assert(false);
    }
    clone.itsReal = itsReal;
    clone.itsImag = itsImag;

    // Return the clone.
    return clone;
  }

  /**
   * Tests for equivalency.
   *
   * <p>
   * All the usual warnings about comparing equality of floating
   * numbers apply.
   *
   * @param o
   *  The complex number to test for equivalancy against.
   *
   * @return
   *  Boolean <code>true</code> if <code>a</code> is equal to this
   *  complex number,
   *  <code>false</code> otherwise.
   */
  public synchronized
  boolean
  equiv(
    Object o
  )
  {
    // The value to return.
    boolean isEquiv = false;
    // Local version of o.
    Complex o1;

    // Prerequisites.
    if((o != null) && (o.getClass() == getClass())) {
      o1 = (Complex)o;
      // Is equal if same object.
      if(equals(o1)) {
        isEquiv = true;
      }
      else {
        // Test the attributes.
        isEquiv = ((o1.itsReal == itsReal) && (o1.itsImag == itsImag));
      }
    }

    return isEquiv;
  }

  /**
   * Test for not-a-number.
   * This complex number is not-a-number if either its real or
   * imaginary components are not-a-number.
   *
   * @return
   *  Boolean <code>true</code> if this complex number is not-a-number,
   *  <code>false</code> otherwise.
   */
  public synchronized
  boolean
  isNaN()
  {
    return ((new Double(itsReal)).isNaN() || (new Double(itsImag).isNaN()));
  }

  /**
   * Test for infinity.
   * This complex number is infinite if either its real or imaginary
   * components is infinite.
   *
   * @return
   *  Boolean <code>true</code> if this complex number is infinite,
   *  <code>false</code> otherwise.
   */
  public synchronized
  boolean
  isInfinite()
  {
    return ((new Double(itsReal)).isInfinite() ||
        (new Double(itsImag)).isInfinite());
  }

  /**
   * Sets the real part of this complex number.
   *
   * @param realPart
   *  The real part.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  setReal(
    double realPart
  )
  {
    itsReal = realPart;

    return this;
  }

  /**
   * Returns the real part of this complex number.
   *
   * @return
   *  The real part.
   */
  public synchronized
  double
  getReal()
  {
    return itsReal;
  }

  /**
   * Sets the imaginary part of this complex number.
   *
   * @param imagPart
   *  The imaginary part.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  setImag(
    double imagPart
  )
  {
    itsImag = imagPart;

    return this;
  }

  /**
   * Returns the imaginary part of this complex number.
   *
   * @return
   *  The imaginary part.
   */
  public synchronized
  double
  getImag()
  {
    return itsImag;
  }

  /**
   * Returns the polar radius of this complex number.
   *
   * @return
   *  The polar radius of this complex number.
   */
  public synchronized
  double
  getRadius()
  {
    return Math.sqrt(Math.pow(itsReal,2) + Math.pow(itsImag,2));
  }

  /**
   * Sets the polar angle of this complex number, keeping the polar
   * radius constant.
   *
   * @param a
   *  The new polar angle.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  setAngle(
    double a
  )
  {
    // The new angle as its wrapper object.
    Double aObj = new Double(a);
    // The current radius (to be maintained).
    double r;

    // Check some special cases.
    if(aObj.isInfinite()) {
      itsReal = Double.NaN;
      itsImag = Double.NaN;
    }
    else if(aObj.isNaN()) {
      itsReal = Double.NaN;
      itsImag = Double.NaN;
    }
    else {
      // Calculate the current radius.
      r = getRadius();

      // Claculate the new real and imaginary parts from the current
      // radius and the new angle.
      itsReal = r * Math.cos(a);
      itsImag = r * Math.sin(a);
    }

    return this;
  }

  /**
   * Returns a <code>String</code> representation of this complex number.
   * Example: 12.3,12.4 or -12.3,-12.4.
   *
   * @return
   *  The string representation of this complex number.
   */
  public synchronized
  String
  toString()
  {
    return ((new Double(itsReal)).toString() + "," +
        (new Double(itsImag)).toString());
  }

  /**
   * Negate this complex number.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  negate()
  {
    // Simply negate both real and imaginary components.
    itsReal = -itsReal;
    itsImag = -itsImag;

    return this;
  }

  /**
   * Calculates the sum of this complex number and another.
   *
   * @param x
   *  The complex number to add to this one.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  add(
    Complex x
  )
  {
    // Simply add real and imaginary components.
    itsReal = itsReal + x.itsReal;
    itsImag = itsImag + x.itsImag;

    return this;
  }

  /**
   * Adds to the real part of this complex number.
   *
   * @param realInc
   *  The quantity to add to the real part.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  addReal(
    double realInc
  )
  {
    // Just add the parameter to the real component.
    itsReal = itsReal + realInc;

    return this;
  }

  /**
   * Adds to the imaginary part of this complex number.
   *
   * @param imagInc
   *  The quantity to add to the imaginary part.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  addImag(
    double imagInc
  )
  {
    // Just add the parameter to the imaginary component.
    itsImag = itsImag + imagInc;

    return this;
  }

  /**
   * Calculates the product of this complex number with a scalar.
   *
   * @param r
   *  The scalar number to multiply by.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  multiply(
    double r
  )
  {
    // Multiply both real and imaginary parts by r.
    itsReal = itsReal * r;
    itsImag = itsImag * r;

    return this;
  }

  /**
   * Multiplies this complex number by another.
   *
   * <p>
   * The first multiplicand is this number.
   * The second multiplicand is the complex number parameter.
   *
   * @param x
   *  The second multiplicand.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  multiply(
    Complex x
  )
  {
    // Temporary storage for the new real component.
    double newReal;
    // Temporary storage for the new imaginary component.
    double newImag;

    // Calculate the product. Save the new new real and imaginary
    // components somewhere else so that they don't break the
    // calculations
    newReal = this.itsReal * x.itsReal - this.itsImag * x.itsImag;
    newImag = this.itsImag * x.itsReal + this.itsReal * x.itsImag;
    this.itsReal = newReal;
    this.itsImag = newImag;

    return this;
  }

  /**
   * Divides this complex number by a scalar.
   *
   * @param r
   *  The scalar number to be the denominator.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  divide(
    double r
  )
  {
    // Divide real and imaginary components by r.
    itsReal = itsReal / r;
    itsImag = itsImag / r;

    return this;
  }

  /**
   * Divides this complex number by another.
   *
   * <p>
   * The numerator is this number.
   * The denominator is the complex number parameter.
   *
   * @param x
   *  The denominator.
   *
   * @return
   *  A reference to this object.
   */
  public synchronized
  Complex
  divide(
    Complex x
  )
  {
    // The denominator for both real and imaginary results.
    double denominator;
    // An intermediate value.
    double t;
    // Temporary storage for the new real component.
    double newReal;
    // Temporary storage for the new imaginary component.
    double newImag;

    // Do differently depending on zone. Put real and imaginary
    // result components in temporary variables so that they don't
    // corrupt the calculation.
    if(Math.abs(x.itsReal) == Math.abs(x.itsImag)) {
      denominator = x.itsReal + x.itsImag;
      newReal = (itsReal + itsImag) / denominator;
      newImag = (itsImag - itsReal) /denominator;
    }
    else if(Math.abs(x.itsReal) < Math.abs(x.itsImag)) {
      t = x.itsReal / x.itsImag;
      denominator = x.itsReal * t + x.itsImag;
      newReal = (itsReal * t + itsImag) / denominator;
      newImag = (itsImag * t - itsReal) / denominator;
    }
    else {
      t = x.itsImag / x.itsReal;
      denominator = x.itsReal + x.itsImag * t;
      newReal = (itsReal + itsImag * t) / denominator;
      newImag = (itsImag - itsReal * t) / denominator;
    }

    itsReal = newReal;
    itsImag = newImag;

    return this;
  }

}

