from __future__ import print_function

import os, sys, shutil
import glob
import time
from xml.parsers.expat import ExpatError, ErrorString
from xml.etree import ElementTree as etree
import re
import string

from .epics_db import OrderedDict, EpicsRecord, EpicsDB

#TODO
# need to replace boy xml write with Etree so xml is well formed
# rework emu_utils
# more waveform types
# better updateFunction (implement arrayCallback directly)
# write waveform handling
# boy xml/javascript for grouping (e.g. PowerInfo)
  # multiple columns
  # header row
# define abbreviations in XML
# multiple devices
# state model
# asyn_utils to use param list values instead of ++index?
# dragonfly ioc n x (bullant + dragonfly)
  # init using DigitalReceiver class

# emu
# handle HOPR, LOPR
# different emu modes (random, normal dist, ramp) - per item?

# initial values - need way to tie initial values (DOL) in XML to class
# convert paramlist to stl container
# mapping from index to name for debugging
# templating for some of the asynUtils & emuUtils

# loadBitfile
  # bitfile query function
  # return a list
    # dynamic enums using asyn

# maximum PV length (must be prefixed with $(prefix)$(antid)$(ss):$(card))
MAX_PV_LENGTH = 46
MAX_MBBI_LENGTH = 16

DefaultXML = '''
<Db>
<iocEnum name="OffOn">
    <iocEnumBit>
        <state0 comment="OFF"/>
        <state1 comment="ON"/>
    </iocEnumBit>
</iocEnum>

<iocEnum name="AlarmEnum">
    <iocEnumValue width="2">
        <state0 comment="OK"/>
        <state1 comment="MINOR"/>
        <state2 comment="MAJOR"/>
        <state3 comment="INVALID"/>
    </iocEnumValue>
</iocEnum>
</Db>
'''

Header = '''/*
 *  @file %s
 *
 *  @copyright (c) 2012 CSIRO
 *  Australia Telescope National Facility (ATNF)
 *  Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 *  PO Box 76, Epping NSW 1710, Australia
 *  atnf-enquiries@csiro.au
 *
 *  This file is part of the ASKAP software distribution.
 *
 *  The ASKAP software distribution is free software: you can redistribute it
 *  and/or modify it under the terms of the GNU General Public License as
 *  published by the Free Software Foundation; either version 2 of the License,
 *  or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 *  @author Craig Haskins<Craig.Haskins@csiro.au>
 *
 *
 *  ********************************************************************************
 *  DO NOT EDIT THIS FILE
 *  This file was automatically generated on %s from XML monitor point
 *  definition files by askap.epicsdb.AdbeParser and should NOT BE DIRECTLY EDITED.
 *  DO NOT EDIT THIS FILE
 *  *********************************************************************************

 */
'''

ParamListHeader = '''
#ifndef %s_PARAM_LIST_H
#define %s_PARAM_LIST_H

#include "asynUtils.h"

namespace %sParams {
enum {
'''

HeaderBody = '''    PL_COUNT
};

static int AsynIndexToAddr[PL_COUNT];

static AskapParameter ParamList[] =
{
'''

HeaderFooter = '''};
} // namespace
#endif //define ASYN_PARAM_LIST_H
'''

TypeMapIn = {
        'float'     :   'ai',
        'int'       :   'longin',
        'int8'      :   'longin',
        'uint8'     :   'longin',
        'uint16'    :   'longin',
        'uint32'    :   'longin',
        'uint64'    :   'stringin',
        'enum'      :   'mbbi',
        'string'    :   'stringin',
        'bool'      :   'bi',
        '??'        :   '??',
        }

TypeMapOut= {
        'float'     :   'ao',
        'int'       :   'longout',
        'int8'      :   'longout',
        'uint8'     :   'longout',
        'uint16'    :   'longout',
        'uint32'    :   'longout',
        'uint64'    :   'stringout',
        'enum'      :   'mbbo',
        'string'    :   'stringout',
        'bool'      :   'bo',
        '??'        :   '??',
        }

TypeMap = {
        'in'    : TypeMapOut,
        'out'   : TypeMapIn
        }

TypeMapWaveform = {
        'float'     :   'FLOAT',
        'double'    :   'DOUBLE',
        'byte'      :   'UCHAR',
        'int'       :   'LONG',
        'uint8'     :   'LONG',
        'uint16'    :   'LONG',
        'uint32'    :   'LONG',
        'string'    :   'STRING',
        'bool'      :   'ENUM',
        '??'        :   '??',
        }

DTypeWaveformMapIn = {
        'float'     :   'asynFloat32ArrayIn',
        'double'    :   'asynFloat64ArrayIn',
        'byte'      :   'asynInt8ArrayIn',
        'int'       :   'asynInt32ArrayIn',
        'uint32'    :   'asynInt32ArrayIn',
        'string'    :   'asynOctetRead',
        '??'        :   '??',
        }

DTypeWaveformMapOut = {
        'float'     :   'asynFloat32ArrayOut',
        'double'    :   'asynFloat64ArrayOut',
        'byte'      :   'asynInt8ArrayOut',
        'int'       :   'asynInt32ArrayOut',
        'uint32'    :   'asynInt32ArrayOut',
        'string'    :   'asynOctetWrite',
        '??'        :   '??',
        }

DTypeWaveformMap = {
        'in'        : DTypeWaveformMapOut,
        'out'       : DTypeWaveformMapIn,
        }

DTypeMapIn = {
        'float'     :   'asynFloat64',
        'int'       :   'asynInt32',
        'int8'      :   'asynInt32',
        'uint8'     :   'asynInt32',
        'uint16'    :   'asynInt32',
        'uint32'    :   'asynInt32',
        'uint64'    :   'asynOctetRead',
        'enum'      :   'asynInt32',
        'string'    :   'asynOctetRead',
        'bool'      :   'asynInt32',
        '??'        :   '??',
        }

DTypeMapOut = {
        'float'     :   'asynFloat64',
        'int'       :   'asynInt32',
        'int8'      :   'asynInt32',
        'uint8'     :   'asynInt32',
        'uint16'    :   'asynInt32',
        'uint32'    :   'asynInt32',
        'uint64'    :   'asynOctetWrite',
        'enum'      :   'asynInt32',
        'string'    :   'asynOctetWrite',
        'bool'      :   'asynInt32',
        '??'        :   '??',
        }

DTypeMap = {
        'in'        : DTypeMapOut,
        'out'       : DTypeMapIn,
        }


ParamTypeMap = {
            'asynInt32'             : 'asynParamInt32',
            'asynFloat64'           : 'asynParamFloat64',
            'asynOctetRead'         : 'asynParamOctet',
            'asynOctetWrite'        : 'asynParamOctet',
            'asynInt8ArrayIn'       : 'asynParamInt8Array',
            'asynInt8ArrayOut'      : 'asynParamInt8Array',
            'asynInt16ArrayIn'      : 'asynParamInt16Array',
            'asynInt16ArrayOut'     : 'asynParamInt16Array',
            'asynInt32ArrayIn'      : 'asynParamInt32Array',
            'asynInt32ArrayOut'     : 'asynParamInt32Array',
            'asynFloat32ArrayIn'    : 'asynParamFloat32Array',
            'asynFloat32ArrayOut'   : 'asynParamFloat32Array',
            'asynFloat64ArrayIn'    : 'asynParamFloat64Array',
            'asynFloat64ArrayOut'    : 'asynParamFloat64Array',
        }

# epics fields should match xml node attributes
EpicsFields = ['EGU', 'PREC', 'HOPR', 'LOPR', 'HIHI', 'HIGH', 'LOLO', 'LOW', 'ZSV', 'OSV', 'ONAM', 'ZNAM', 'LINKPV', 'SCAN', 'EVNT', 'DISV']
EpicsInputFields = []
EpicsOutputFields = ['DOL', 'OMSL']

EpicsDirFields = {
        'in'    : EpicsOutputFields,
        'out'   : EpicsInputFields}

# add mbbi fields
MbbiPrefix = ['zr', 'on', 'tw', 'th', 'fr', 'fv', 'sx', 'sv', 'ei', 'ni', 'te', 'el', 'tv', 'tt', 'ft', 'ff']
EpicsFields += [x.upper() + 'VL' for x in MbbiPrefix]
EpicsFields += [x.upper() + 'ST' for x in MbbiPrefix]
EpicsFields += [x.upper() + 'SV' for x in MbbiPrefix]

# these xml node attribute names need mapping to EPICS (or askap.epicsdb) fields
KeyMap = {'comment'   :   'LONGDESC'}

Limits = [ 'lolo', 'hihi' ]
DefaultValues = {
        'lolo' : 
        {
            'float'     : '0.0',
            'int'       : '0',
            'int8'      : '-127',
            'uint8'     : '0',
            'uint16'    : '0',
            'uint32'    : '0',
            'uint64'    : '0',
            'enum'      : '0',
            'bool'      : 'false',
            'string'    : '"? ?"',
            '??'        : '0'
        },
        'hihi' : 
        {
            'float'     : '1000',
            'int'       : '42',
            'int8'      : '128',
            'uint8'     : '255',
            'uint16'    : '65535',
            'uint32'    : '65535',
            'uint64'    : '65535',
            'enum'      : '142',
            'bool'      : 'true',
            'string'    : '"? ?"',
            '??'        : '100'
        }}


def node_to_string(node):
    return 'node: ' + node.tag + ' ' + node.get('fullname', 'unknown') + ' PV name: ' + node.get('pvname', 'unknown')

def needs_resolving(node):
    nodeType = node.get('type', '')
    return nodeType in ('top', 'direct')

def new_summary_record(node, calcEvent=0):
    record = EpicsRecord()

    comment = node.get('comment', '')

    if len(comment) > 39:
        record['DESC'] = comment[0:39] + '>'
    elif len(comment) > 0:
        record['DESC'] = comment

    record['REC_TYPE'] = 'aSub'

    params = node.get('params', '')
    if len(params) > 0:
        params = ':' + params
    
    record['SNAM'] = 'askapioc_asub_' + node.get('type', 'sum')
    # full name
    record['REG_NAME'] = node.get('fullname', '??')
    record['SCAN'] = 'Event'
    record['EVNT'] = str(100 + calcEvent)
    record['FLNK'] = "$(p)" + record['REG_NAME'] + ":calc"
    record['OUTA'] = record['REG_NAME'] + ":val PP MSS"
    record['OUTB'] = record['REG_NAME'] + ":alarm PP MSS"
    record['FTVB'] = 'ENUM'
    if 'dominoTemp' in record['REG_NAME']:
        record['TPRO'] = '0'

    return record

def add_summary_record(db, pvName, root, parent, node):
    calcEvent = 0
    record = new_summary_record(node, 0)
    calcEvent += 1
    x = 0
    numCalcs = 1
    for child in node:
        if 'iocSearch' != child.tag:
            continue
        name = child.get('name', 'undefined')
        point = child.get('point', 'undefined').split(',')
        egu = child.get('egu', 'undefined').split(',')
        excludeSpec = child.get('exclude')

        if 'undefined' in point:
            findPointFunc = lambda x: True
        else:
            findPointFunc = lambda x: x.get('name') in point

        if 'undefined' in egu:
            findEguFunc = lambda x: True
        else:
            findEguFunc = lambda x: x.get('egu') in egu

        if excludeSpec is not None:
            excludeSpec = excludeSpec.split(';')
        else:
            excludeSpec = []
        #print("FIND", name, " point ", point, " EGU ", egu)
        for n in root.getiterator():
            nodeName = n.get('fullname')
            if name in nodeName and n not in node and n.tag in ('iocPoint', 'iocEnumBit') and findPointFunc(n) and findEguFunc(n):
                if any([ excludeStr in nodeName for excludeStr in excludeSpec]):
                    #print('excluding %s' % nodeName)
                    continue
                key = 'INP' + string.uppercase[x]
                record[key] = n.get('pvname')
                nodeType = n.get('type')
                if nodeType in TypeMapWaveform:
                    record['FT' + string.uppercase[x]] = TypeMapWaveform[nodeType]
                else:
                    raise RuntimeError('node %s type %s not in TypeMap' % (nodeName, nodeType))
                #print('%s = %s ' % (key, record[key]))
                x += 1
                if x > 20:
                    record['FLNK'] = pvName
                    del record['OUTA']
                    del record['OUTB']
                    del record['FTVB']
                    db[pvName + "%d" % numCalcs] = record
                    record = new_summary_record(node, 1)
                    calcEvent += 1
                    x = 0
                    numCalcs += 1

    #print("NUMCALCS = ", numCalcs)
    if numCalcs > 21:
        calcIndex = 0
        calcs = numCalcs
        record['FLNK'] = pvName
        del record['OUTA']
        del record['OUTB']
        del record['FTVB']
        db[pvName + '%d' % numCalcs] = record
        totalRecord = new_summary_record(node)
        while calcs > 0:
            sumRecord = new_summary_record(node, 3)
            calcEvent += 1
            del sumRecord['OUTA']
            del sumRecord['OUTB']
            del sumRecord['FTVB']
            for x in xrange(0, 21):
                sumRecord['INP' + string.uppercase[x]] = '%s%d.VALA' % (pvName, calcIndex * 21 + x + 1)
                db['%s%d' % (pvName, calcIndex * 21 + x + 1)]['FLNK'] = pvName + string.uppercase[calcIndex]
                calcs -= 1
                if 0 == calcs:
                    break
            db[pvName + string.uppercase[calcIndex]] = sumRecord
            totalRecord['INP' + string.uppercase[calcIndex]] = '%s.VALA' % (pvName + string.uppercase[calcIndex])
            calcIndex += 1
        totalRecord['EVNT'] = str(104)
        db[pvName] = totalRecord
    elif numCalcs > 1:
        record['FLNK'] = pvName
        del record['OUTA']
        del record['OUTB']
        del record['FTVB']
        db[pvName + '%d' % numCalcs] = record
        sumRecord = new_summary_record(node, 2)
        calcEvent += 1
        for x in xrange(0, numCalcs):
            sumRecord['INP' + string.uppercase[x]] = '%s%d.VALA' % (pvName, x+1)
        db[pvName] = sumRecord
    else:
        db[pvName] = record

    recFrag = EpicsRecord()
    sumRecName = '$(p)' + pvName
    recFrag['REG_NAME'] = sumRecName
    recFrag['REC_TYPE'] = 'aSub'
    recFrag['INP$(inpIndex)'] = pvName + '.VALA'
    db[sumRecName] = recFrag

def add_record(db, pvName, root, parent, node):
    record = EpicsRecord()

    comment = node.get('comment', '')
    nodeType = node.get('type', '??').strip(' ')
    nodeSize = int(node.get('size', 0))

    # outputs are inputs in EPICS and vice versa
    nodeDir = node.get('dir', 'out')

    # enum record are a special case
    if node.get('zrvl') is not None:
        nodeType = 'enum'

    if len(comment) > 39:
        record['DESC'] = comment[0:39] + '>'
    elif len(comment) > 0:
        record['DESC'] = comment

    if nodeSize > 0 and nodeType in TypeMapWaveform:
        # waveform record
        record['REC_TYPE'] = 'waveform'
        record['FTVL'] = TypeMapWaveform[nodeType]
        record['DTYP'] = DTypeWaveformMap[nodeDir][nodeType]
        record['NELM'] = str(nodeSize)
    elif node.get('scan') is not None and node.get('scan') != 'Event':
        record['REC_TYPE'] = TypeMap[nodeDir][nodeType]
    elif nodeType in TypeMap[nodeDir]:
        record['REC_TYPE'] = TypeMap[nodeDir][nodeType]
        record['DTYP'] = DTypeMap[nodeDir][nodeType]

    else:
        raise RuntimeError('unhandled type %s for %s' % (nodeType, node.get('fullname')))

    params = node.get('params', '')
    if len(params) > 0:
        params = ':' + params

    # TODO all records should be asyn??

    if node.get('scan') is None or node.get('scan') == 'Event':
        asynName =  node.get('asyn', node.get('pvname', '??')).replace(':', '_')
        asynName = asynName.rstrip('_O')
        asynStr = '@asyn($(PORT))' + asynName  + params
        if 'out' == nodeDir:
            record['SCAN'] = 'I/O Intr'
            record['INP'] = asynStr
        elif 'waveform' == record['REC_TYPE']:
            record['INP'] = asynStr
        else:
            record['OUT'] = asynStr

    # full name
    record['REG_NAME'] = node.get('fullname', '??')

    for key, val in node.attrib.items():
        if key.upper() in EpicsFields or key.upper() in EpicsDirFields[nodeDir]:
            record[key.upper()] = val
        elif key in KeyMap:
            record[KeyMap[key]] = val

    # uint64 records can't have egu since converted them to strings
    if 'uint64' == nodeType and 'EGU' in record:
        del record['EGU']

    # hopr, lopr & alarm severities
    hihi = node.get('hihi')
    autosaveFields = []
    if hihi is not None:
        record['HHSV'] = 'MAJOR'
        if hihi != '':
            autosaveFields.append('HIHI')
            hihi = float(hihi)
            hopr = hihi + abs(0.1 * hihi)
            if 'float' == nodeType:
                record['HOPR'] = str(hopr)
            else:
                record['HOPR'] = str(int(hopr))

    lolo = node.get('lolo')
    if lolo is not None:
        record['LLSV'] = 'MAJOR'
        if lolo != '':
            autosaveFields.append('LOLO')
            hihi = float(hihi)
            lolo = float(lolo)
            lopr = lolo - abs(0.1 * lolo)
            if 'float' == nodeType:
                record['LOPR'] = str(lopr)
            else:
                record['LOPR'] = str(int(lopr))

    if 'high' in node.attrib:
        autosaveFields.append('HIGH')
        record['HSV'] = 'MINOR'

    if 'low' in node.attrib:
        autosaveFields.append('LOW')
        record['LSV'] = 'MINOR'

    # archive all changes
    # TODO not really useful since asyn only updates records on change
    #if nodeType in ( 'float', 'int', 'int8', 'uint8', 'uint16', 'uint32') and nodeSize == 0:
    #    record['MDEL'] = '-1'

    # epics autosave alarm limits
    record['autosaveFields'] = ' '.join(autosaveFields)

    db[pvName] = record
    #return record

def abbreviate(name):
    Abbreviations = {
            'CtrlMonitorData'      : 'bul',
            'DragonflyMonitorData' : 'dig',
            'RedbackMonitorData'   : 'dsp',
            'DominoInfo'           : 'dom',
            'TRDMonitorData'       : 'trd',
            'PafCtrlInfo'          : 'ctrl',
            'PafPsuInfo'           : 'psu',
            'OpticalInfoArray'     : 'optiInfo',
            'OpticalChannelArray'  : 'optiChan',
            'channel'              : 'chan',
            'backplane'            : 'bp',
            'SnData'               : 'Sn',
            }
    abbreviated = name
    for (key, abbr) in Abbreviations.items():
        abbreviated = abbreviated.replace(key, abbr)
    return abbreviated

def indent(elem, level=0):
    i = "\n" + level*"  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            indent(elem, level+1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i

def clone_node(node, level=0, regex=None):
    #print(' ' * level, 'cloning', node.tag, node.attrib, len(node))
    ret = etree.Element(node.tag, node.attrib)
    ret.text = node.text
    ret.tail = node.tail
    for child in node:
        #print('NODE %s' % child.get('fullname'))
        #if child.tag in ('iocPoint', 'iocEnum') and regex is not None and regex != child.get('name'):
        #    print('FILTER OUT %s' % child.get('fullname'))
        #    continue
        #print(' ' * level, 'cloning children')
        ret.append(clone_node(child, level+1, regex))
    return ret

def update_node(dst, src):
    '''
    updates iocPoint and iocStructres.
    unnamed nodes are copied to all matching types.
    named nodes need to match on name
    '''
    #print('updating %s %s %s from %s %s %s' % (dst.tag, dst.get('type'), dst.get('name'), src.tag, src.get('type'), src.get('name')))
    #print('dst', dst.attrib)
    #print('src', src.attrib)
    dstName = dst.get('name')
    srcName = dst.get('name')
    srcType = src.get('type')
    if dst.tag == src.tag and (dstName is None or dstName == srcType or dstName == srcName):
        dst.attrib.update(src.attrib)
        for (x, dstChild) in enumerate(dst):
            if len(src) > x:
                update_node(dstChild, src[x])

def replace_node(parent, oldNode, newNode, clear_attributes=True):
    if clear_attributes:
        oldNode.clear()
    else:
        for child in oldNode.findall('./*'):
            oldNode.remove(child)

    oldNode.attrib.update(newNode.attrib)
    for child in newNode:
        oldNode.append(child)

def bit_length(num):
    length = 0
    while(num):
        num >>= 1
        length += 1

    return length

def ms_to_seconds(ms):
    result = 0
    minutes = re.findall('(\d+)m', ms)
    seconds = re.findall('(\d+)s', ms)
    if len(minutes) > 0:
        result = 60 * int(minutes[0])
    if len(seconds) > 0:
        result += int(seconds[0])

    if result>0:
        return result

    return None 

class CodeWriter(file):
    def __init__(self, name, mode, debugMode=False):
        file.__init__(self, name, mode)

    def writeIn(self, level, str):
        file.write(self, '  ' * level)
        file.write(self, str)

class AdbeParser():
    def __init__(self, appName, dbPrefix, filePrefix, srcOutDir, dbOutDir=None, xmlOutDir=None, monicaDir=None, debug=False, debugCode=False, archiveAll=False):
        self._appName = appName
        self._dbPrefix = dbPrefix
        self._filePrefix = filePrefix
        self._srcOutDir = srcOutDir
        self._dbOutDir = dbOutDir
        self._xmlOutDir = xmlOutDir
        self._monicaDir = monicaDir
        self._debug = debug
        self._debugCode = debugCode
        self._archiveAll = archiveAll

        self._resolvedName = os.path.join(srcOutDir, filePrefix + '_resolved.xml')

        self._verbose = True
        if '-q' in sys.argv or '--quiet' in sys.argv:
            self._verbose = False

    def log(self, *args, **kwargs):
        if self._verbose:
            print('AdbeParser: ', *args, **kwargs)

    def dlog(self, *args, **kwargs):
        if self._debug:
            self.log(*args, **kwargs)

    def elog(self, *args, **kwargs):
        print('AdbeParser: ', *args, **kwargs)

    def llog(self, level, *args, **kwargs):
        self.dlog(' ' * level, *args, **kwargs)

    def warn(self, *args, **kwargs):
        self.log("WARN:", *args, **kwargs)

    def parse(self, source, libName=None, exclude=None, include=None, epicsxml=False):
        try:
            lineMap = None
            self.excludedNodes = exclude or []
            self.includedNodes = include
            if source.endswith('.xml'):
                tree = etree.ElementTree()
                tree.parse(source)
            else:
                xml, lineMap = self.parse_header(source)
                tree = etree.ElementTree(etree.fromstring(xml))

            parts = source.split(os.path.sep)
            if len(parts) > 1:
                library = source.split(os.path.sep)[-2]
                header = source.split(os.path.sep)[-1]
            else:
                library = ''
                header = source

            self.includeFiles.append( (libName, header) ) 
            self.sourceFiles.append(source)
            self.expand_macros(tree.getroot(), None, tree.getroot(), 0)
            self.resolve_node(tree.getroot(), None, tree.getroot(), 0)
            for child in tree.getroot():
                if epicsxml:
                    child.set('epicsxml', 'True')
                self.root.append(child)
            self.dlog('TREE is now', len(self.root))

        except ExpatError as e:
            if lineMap is None:
                lineno = e.lineno
            else:
                lineno = lineMap[e.lineno]
            self.elog('XML error at %s line %d (%d in extracted XML) : %s' % (source, lineno, e.lineno, ErrorString(e.code)))
            exit(-1)

        except etree.ParseError as e:
            if lineMap is None:
                lineno = e.position[0]
            else:
                lineno = lineMap[e.position[0]]
            self.elog('XML error at %s line %d (line %d, column %d in extracted XML) : %s' % (source, lineno, e.position[0], e.position[1], ErrorString(e.code)))
            exit(-1)

    def parse_header(self, header):
        '''
        given a header filename, extract doxygen xml tags
        and parse the resulting XML document with ElementTree
        
        :param header: filename of header to parse
        '''
        if not os.path.exists(header):
            raise RuntimeError('%s does not exists.  Make sure any dependencies are built first' % header)
        xml = '<Db>\n'
        srcLine = 1
        xmlLine = 2
        lineMap = {}
        with open(header, 'r') as f:
            xmlOn = False
            for line in f:
                add = ''
                if re.search('/\*\*\ *@xmlonly', line):
                    m = re.search('.*@xmlonly\ *(.*)', line)
                    if m:
                        add = m.group(1).replace('@endxmlonly */', '\n')
                    if '@endxmlonly' not in line:
                        xmlOn = True
                elif xmlOn:
                    add = line.replace('@endxmlonly', '')
                    add = add.replace('*/', '')
                    if '@endxmlonly' in line:
                        xmlOn = False

                if len(add) > 0:
                    xml += add.strip(' ')
                    lineMap[xmlLine] = srcLine
                    if '\n' in add:
                        xmlLine += 1

                srcLine += 1

        xml += '</Db>'

        if not os.path.exists(self._srcOutDir):
            os.makedirs(self._srcOutDir)
        extractedName = os.path.join(self._srcOutDir, 'extracted_' + os.path.basename(header.strip('.h')) + '.xml')
        try:
            # try to write formatted XML if XML is valid
            tree = etree.ElementTree(etree.fromstring(xml))
            indent(tree.getroot())
            tree.write(extractedName)
        except (ExpatError, etree.ParseError) as e:
            # otherwise dump it as is
            with open(extractedName, 'w') as f:
                f.write(xml)

        self.fileList.append(extractedName)

        return xml, lineMap

    def reset(self):
        self.maxLength = 0
        self.recordTypes = {}
        self.fileList = []
        self.includeFiles = []
        self.sourceFiles = []
        self._monitorPointsXml = []
        self.resolveFuncs = {
                'iocArray'      : self.resolve_ioc_array,
                'iocStructure'  : self.resolve_ioc_structure,
                'iocFunction'   : self.resolve_ioc_function,
                'iocSummary'    : self.resolve_ioc_summary,
        }

        self.excludedNodes = []
        self.includedNodes = None
        self.paramList = OrderedDict()

        self.tree = etree.ElementTree(etree.fromstring(DefaultXML))
        self.resolve_node(self.tree.getroot(), None, self.tree.getroot(), 0)
        self.root = self.tree.getroot()

    def dump(self):
        self.printNodes(self.root, 0)

    def dump_pvs(self, db):
        for pv, attrib in db.ordered_items():
            print(pv, attrib)

    def expand_macros(self, root, parent, node, level):
        macro = node.get('macro')
        if macro is not None:
            del node.attrib['macro']
            macroNode = clone_node(node)
            macroList = macro.split(',')
            nodeCount = 1
            macroValues = {}
            macroStop = {}

            for m in macroList:
                (macroName, macroRange) = m.split('=')
                (start, stop) = macroRange.split('..')
                nodeCount *= int(stop) - int(start) + 1
                self.llog(level, "EXPAND", macroName, start, stop)
                macroValues[macroName] = int(start)

            macroNum = len(macroList) - 1
            for i in range(0, nodeCount):
                newNode = clone_node(macroNode)
                asynName = newNode.get('name')
                for (mkey, mval) in macroValues.items():
                    asynName = asynName.replace('%%%s' % mkey, 'X')
                for (key, value) in newNode.attrib.items():
                    for (mkey, mval) in macroValues.items():
                        value = value.replace('%%%s' % mkey, '%d' % mval)
                    newNode.set(key, value)
                if not int(node.get('expandasyn', "0")):
                    newNode.set('asyn', asynName)

                if i == 0:
                    replace_node(parent, node, newNode)
                else:
                    parent.append(newNode)

                # increment macro array
                carry = True
                for m in reversed(macroList):
                    if not carry:
                        break
                    carry = False
                    (macroName, macroRange) = m.split('=')
                    (start, stop) = macroRange.split('..')
                    macroValues[macroName] += 1
                    if macroValues[macroName] > int(stop):
                        macroValues[macroName] = int(start)
                        carry = True

        for child in node:
            self.expand_macros(root, node, child, level + 1)

    def fixup_nodes_for_epics(self, node):
        nodeType = node.get('type', '??')
        if 'iocPoint' != node.tag:
            return

        if 'float' == nodeType:
            if node.get('prec') is None:
                node.set('prec', '1')

        uppercaseFields = [x.upper() + 'ST' for x in MbbiPrefix]
        uppercaseFields += ['osv', 'zsv']
        for field in uppercaseFields:
            if node.get(field) is not None:
                node.set(field, node.get(field).upper())

    def find_node(self, root, tag, name):
        self.dlog('finding', tag, name)
        for r in (root, self.root):
            #print('finding in', r)
            for node in r.findall('./%s' % tag):
                #print('finding in node', node, node.get('name'))
                if name == node.get('name'):
                    self.dlog('found it')
                    return node
        self.dlog('no luck')

    def resolve_ioc_array(self, parent, node, srcNode, level):
        '''
        :param parent:  parent to iocArray node
        :param node:    the iocArray node
        :param srcNode: node to resolve Array with
        '''
        newNode = clone_node(srcNode)
        children = list(newNode)

        # find and apply all overrides
        items = node.findall('./item')
        baseNum = int(node.get('base', '1'))
        for x in xrange(0, int(node.get('number'), 0)):
            for (y, child) in enumerate(children):
                itemNode = clone_node(child)
                itemNode.set('name', node.get('name'))
                if len(node) > 0:
                    update_node(itemNode, node[0])
                if len(items) > x and len(items[x]) > y:
                    update_node(itemNode, items[x][y])
                itemNode.set('index', str(x + baseNum))
                newNode.append(itemNode)
        
        for child in children:
            newNode.remove(child)

        update_node(newNode, node)
        newName = newNode.get('name', '')

        nodeNames = [x.get('name') for x in newNode]
        uniqueNames = len({}.fromkeys(nodeNames)) == len(nodeNames)
        for child in newNode:
            childName = child.get('name')
            childIndex = child.get('index','')
            if not uniqueNames and '%i' not in childName:
                if childName[-1].isdigit():
                    childName += '_'
                childName += '%i'
            childName = childName.replace('%i', childIndex)
            child.set('name', childName)

        self.llog(level, 'ARRAY', newNode.tag, newName, len(newNode))

        # CRH test for unused overrides
        # CRH can I use node update here instead of update_node call
        replace_node(parent, node, newNode)

    def resolve_ioc_structure(self, parent, node, srcNode, level):
        '''
        expands and iocStructure (with type attrib)
        '''
        if node.get('type') is None:
            self.warn(node.tag, node.get('name'), "doesn't need resolving")
            return

        self.llog(level, 'SRCNODES', [ x.get('name') for x in srcNode])
        newNode = clone_node(srcNode, regex=node.get('regex'))
        self.llog(level, 'NEWNODES', [ x.get('name') for x in newNode])
        update_node(newNode, node)
        newName = newNode.get('name', '')
        self.llog(level, 'STRUCT', newNode.tag, newName)
        self.llog(level, 'NEWNODES', [ x.get('name') for x in newNode])

        # CRH test for unused overrides
        # CRH can I use node update here instead of update_node call
        replace_node(parent, node, newNode)

    def resolve_ioc_summary(self, parent, node, srcNode, level):
        nodeName = node.get('name', '??')
        nodeType = node.get('type', '')
        pvName = node.get('pvname', '??')

        if nodeName.startswith('S_'):
            self.dlog('already done ioc summary', nodeName)
            return

        node.set('name', 'S_' + nodeName)
        node.set('pvname', 'S_' + pvName)
        node.set('fullname', 'S_' + pvName)

        newNode = etree.Element('iocPoint', {
            'type'  : 'float',
            'name'  : 'val',
            'dir'   : 'out',
            'scan'  : 'Passive'})
        for attrib in ('egu', 'archive', 'comment', 'lopr', 'lolo', 'low', 'high', 'hihi', 'hopr'):
            val = node.get(attrib)
            if val is not None:
                newNode.set(attrib, val)
        params = node.get('params')
        if params is not None:
            newNode.set('params', newNode.get('params', '') + ',' + params)

        node.insert(0, newNode)

        newNode = etree.Element('iocPoint', {
            'type'      : 'AlarmEnum',
            'lookup'    : "AlarmEnum",
            'name'      : 'alarm',
            'dir'       : 'out',
            'scan'      : 'Passive'})
        for attrib in ('egu', 'archive', 'comment', 'lopr', 'lolo', 'low', 'high', 'hihi', 'hopr'):
            val = node.get(attrib)
            if val is not None:
                newNode.set(attrib, val)
        params = node.get('params')
        if params is not None:
            newNode.set('params', newNode.get('params', '') + ',' + params)

        node.insert(0, newNode)
        self.llog(level, 'IOCFUNCTION', node.get('name'))

    def resolve_ioc_function(self, parent, node, srcNode, level):
        nodeName = node.get('name', '??')
        nodeType = node.get('type', '')
        pvName = node.get('pvname', '??')

        if nodeName.startswith('F_'):
            self.dlog('already done iocFunction', nodeName)
            return

        node.set('name', 'F_' + nodeName)
        node.set('pvname', 'F_' + pvName)
        node.set('fullname', 'F_' + pvName)

        if 'direct' != nodeType:
            newNode = etree.Element('iocPoint', {'type' : 'bool', 'name' : 'exec', 'dir' : 'in'})
            params = node.get('params')
            if params is not None:
                newNode.set('params', newNode.get('params', '') + ',' + params)
            node.insert(0, newNode)

        self.llog(level, 'IOCFUNCTION', node.get('name'))

    def resolve_node(self, root, parent, node, level):
        name = node.get('name', '')
        nodeType = node.get('type', None)
        nodeDir = node.get('dir', '')

        prefix = ''
        if parent is not None:
            parentName = parent.get('fullname', '')
            if len(parentName) > 0:
                if parent.tag in ('iocStatus', 'iocEnum', 'iocArray'):
                    # supress this level in PV naming
                    parentName = parentName.replace(name, '')
                    parts = parentName.split(':')
                    prefix = ':'.join(parts[0:-1]) + ':'
                elif 0 == len(name):
                    prefix = parentName
                else:
                    prefix = parentName + ':'

        fullName = prefix + name
        pvName = abbreviate(fullName)
        node.set('fullname', fullName)
        node.set('pvname', pvName)
        if node.get('asyn') is not None and not prefix in node.get('asyn'):
            node.set('asyn', prefix + node.get('asyn'))

        self.llog(level, 'RESOLVING', node.tag, name)

        if parent is not None:
            if 'iocStatus' == parent.tag:
                node.set('linkpv', parent.get('pvname'))
            linkpv = parent.get('linkpv')
            if linkpv is not None:
                node.set('linkpv', linkpv)

        if node.tag == 'iocStatus' and node.get('resolved') is not None:
            pass
        elif node.tag in ('iocPoint', 'iocStatus'):
            # must have a type
            if nodeType is None:
                raise RuntimeError('type not specified in %s' % node_to_string(node))

            rbNodeList = []
            self.fixup_nodes_for_epics(node)
            lookup = node.get('lookup')
            if lookup is None and 'bool' == nodeType:
                lookup = 'OffOn'
            if lookup is not None:
                lookupNode = self.find_node(root, 'iocEnum', lookup)
                if lookupNode == None:
                    raise RuntimeError("Can't find lookup %s" % lookup)

                newNode = clone_node(lookupNode)
                del newNode.attrib['name']
                del newNode.attrib['fullname']
                del newNode.attrib['pvname']
                for bitNode in newNode:
                    dir = node.get('dir')
                    if dir is not None:
                        bitNode.set('dir', dir)
                    if bitNode.get('name') is None:
                        if 'iocStatus' == node.tag or bitNode.get('bit') is None:
                            bitNode.set('name', name)
                        else:
                            bitNode.set('name', '%s:B%s' % (name,bitNode.get('bit')))
                    else:
                        bitNode.set('name', '%s:%s' % (name, bitNode.get('name')))
                    if 'iocEnumBit' == bitNode.tag:
                        bitNode.set('type', 'bool')
                        bitNode.set('width', '1')
                        maxBit = int(bitNode.get('bit', '0'))
                        maxVal = (1 << maxBit) - 1
                        newNode.set('max', str(maxVal))
                        stateNames = [ 'znam', 'onam']
                        stateSevr = ['zsv', 'osv']
                        for stateNode in bitNode:
                            state = int(stateNode.tag[len('state'):])
                            bitNode.set(stateNames[state], stateNode.get('comment'))
                            sevr = stateNode.get('sevr')
                            if sevr is not None:
                                bitNode.set(stateSevr[state], sevr)
                        bitNode.set('comment', bitNode.get('onam'))

                    elif 'iocEnumValue' == bitNode.tag:
                        bitNode.set('type', 'int')
                        #bitNode.set('comment', node.get('comment', lookupNode.get('comment', '')))
                        for attrib in ('params', 'asyn', 'scan'):
                            if node.get(attrib) is not None:
                                bitNode.set(attrib, node.get(attrib))
                        width = int(bitNode.get('width', '0'))
                        if 0 == width:
                            self.warn("width not set for %s:%s" % (name, bitNode.get('name')))
                            # set minimum width possible
                            lastState = int(bitNode[-1].tag[len('state'):])
                            width = bit_length(lastState)
                            bitNode.set('width', str(width))
                        newNode.set('max', str((1 << width) -1))
                        for stateNode in bitNode:
                            self.fixup_nodes_for_epics(stateNode)
                            state = int(stateNode.tag[len('state'):])
                            sevr = stateNode.get('sevr', '')
                            if sevr is not None:
                                bitNode.set(MbbiPrefix[state] + 'sv', sevr)

                            comment = stateNode.get('comment', str(state))
                            if len(comment) > MAX_MBBI_LENGTH:
                                self.warn(' string "%s" too long in %s' % (comment, fullName))
                                comment = comment[0:MAX_MBBI_LENGTH]
                            bitNode.set(MbbiPrefix[state] + 'st', comment)
                            bitNode.set(MbbiPrefix[state] + 'vl', str(state))
                        
                    # remove state nodes since they have been
                    # incorporated into the enumBit node
                    for stateNode in bitNode.findall('./*'):
                        bitNode.remove(stateNode)

                    if 'both' == dir:
                        self.llog(level, 'READBACK', name)
                        rbNode = clone_node(bitNode)
                        rbNode.set('dir', 'out')
                        rbNodeList.append(rbNode)
                        dir = 'in'
                        bitNode.set('dir', dir)
                        #self.warn("R/W for enum type not yest supported")

                    if 'in' == dir and not name.endswith('_O') and not node.get('nosuffix', False):
                        bitNode.attrib['name'] += '_O'
                        bitNode.attrib['pvname'] += '_O'
                        bitNode.attrib['fullname'] += '_O'
                        name = bitNode.get('name')
                        self.llog(level, 'OUTPUT', name)

                for rbNode in rbNodeList:
                    newNode.append(rbNode)

                node.insert(0, newNode)
                if len(newNode) > 1:
                    # include bitfield record for mbbi
                    newNode.insert(0, etree.Element('iocPoint', 
                            {'name' : name, 'pvname': pvName, 'fullname' : fullName,
                             'type' : 'uint32', 'hihi' : '1', 'comment' : "bitfield status"
                            }))

                node.set('resolved', '')
                if 'iocPoint' == node.tag:
                    # iocPoints are now just containers
                    replace_node(parent, node, newNode, clear_attributes=False)
                    node.tag = 'iocEnum'

            self.recordTypes[nodeType] = True
            self.maxLength = max(self.maxLength, len(pvName))

            if 'both' == nodeDir:
                self.llog(level, 'READBACK', name)
                rbNode = clone_node(node)
                rbNode.set('dir', 'out')
                parent.append(rbNode)
                nodeDir = 'in'
                node.set('dir', nodeDir)

            if 'in' == nodeDir and not name.endswith('_O') and not node.get('nosuffix', False):
                node.attrib['name'] += '_O'
                node.attrib['pvname'] += '_O'
                node.attrib['fullname'] += '_O'
                name = node.get('name')
                self.llog(level, 'OUTPUT', name)

        elif 'iocFunction' == node.tag or 'iocSummary' == node.tag:
            resolveFn = self.resolveFuncs[node.tag]
            resolveFn(parent, node, None, level)

            self.llog(level, 'RESOLVED', node.tag, nodeType, name)

        elif needs_resolving(node) or node.tag in ('Db', 'iocSearch') or node.tag.startswith('iocEnum') or node.tag.startswith('state'):
            self.llog(level, "skipping")
            pass
        elif node.tag in self.resolveFuncs:
            resolveFn = self.resolveFuncs[node.tag]
            sourceNode = self.find_node(root, node.tag, nodeType)
            if sourceNode is not None:
                resolveFn(parent, node, sourceNode, level)
                self.llog(level, 'RESOLVED', node.tag, nodeType, name)
            #else:
            #    self.warn("can't resolve", name, 'to', nodeType, node.tag, node.attrib)
        else:
            self.warn("can't resolve", name, 'to', nodeType, node.tag, node.attrib)

        excluded = []
        for child in node:
            childName = child.get('name', '')
            childType = child.get('type', '')
            self.llog(level, "CHILD", child.tag, childName)
            if childType != 'top' or (childName not in self.excludedNodes and (self.includedNodes is None or childName in self.includedNodes)):
                self.resolve_node(root, node, child, level + 1)
            else:
                excluded.append(child)
                self.llog(level, "EXCLUDING", childName, child)

        for child in excluded:
            self.llog(level, 'REMOVING', child)
            node.remove(child)

    def node_to_record(self, db, root, parent, node):

        #print('node to record', node)
        if 'iocSummary' == node.tag:
            pvName = node.get('pvname', '??')
            #print("IOCSUMMARY", pvName)
            add_summary_record(db, pvName + ':calc', root, parent, node)

        elif node.tag in ('iocPoint', 'iocEnumBit', 'iocEnumValue') and node.get('hide') is None:
            pvName = node.get('pvname', '??')
            add_record(db, pvName, root, parent, node)

        for child in node:
            self.node_to_record(db, root, node, child)

    def debugCode(self, file, msg):
        if self._debugCode:
            file.write(msg)

    def write_to_epics_db(self, prefix):
        commonDb = EpicsDB()
        for child in self.root:
            childType = child.get('type', '')
            childName = child.get('name', '')
            if 'asyn' == childType:
                continue
            if 'top' == childType:
                # each "top" tree will get it's own DB
                topDb = EpicsDB()
                self.node_to_record(topDb, self.root, self.root, child)
                topDb.add_prefix(self._dbPrefix)
                outputFile = prefix + '_%s_auto.db' % childName
                with open(outputFile, 'w') as f:
                    topDb.save_to_db(f)
                self.fileList.append(outputFile)
            elif needs_resolving(child) or 'iocFunction' == child.tag or 'iocSummary' == child.tag:
                self.node_to_record(commonDb, self.root, self.root, child)

        outputFile = prefix + '_auto.db'
        commonDb.add_prefix(self._dbPrefix)
        with open(outputFile, 'w') as f:
            commonDb.save_to_db(f)
        self.fileList.append(outputFile)

    def build_param_list(self, node):
        self.dlog("build_param_list", node.tag, node.get('name'))
        if 'iocStructure' == node.tag:
            name = node.get('fullname').replace(':', '_')
            name += '_BEGIN'
            if name in self.paramList:
                pass
                #raise RuntimeError('param %s already exists: %s & %s' % (name, node_to_string(self.paramList[name]), node_to_string(node)))
            self.paramList[name] = node

        elif node.tag in ('iocPoint', 'iocEnumBit', 'iocEnumValue'):
            name = node.get('asyn', node.get('fullname', '??')).replace(':', '_')
            if name in self.paramList and self.paramList[name].get('dir','') == node.get('dir', ''):
                pass
                #raise RuntimeError('param %s already exists: %s & %s' % (name, node_to_string(self.paramList[name]), node_to_string(node)))
            name = name.rstrip('_O')
            self.paramList[name] = node

        for child in node:
            self.build_param_list(child)

        if 'iocStructure' == node.tag:
            name = node.get('fullname').replace(':', '_')
            name += '_END'
            if name in self.paramList:
                pass
                #rais RuntimeError('param %s already exists: %s & %s' % (name, node_to_string(self.paramList[name]), node_to_string(node)))
            self.paramList[name] = node

    def write_asyn_param_list(self, dir, prefix):
        for child in self.root:
            if needs_resolving(child) or 'iocFunction' == child.tag or 'asyn' == child.get('type', ''):
                self.build_param_list(child)

        filename = os.path.join(dir, prefix + '_paramList.h')
        outputFile = open(filename, 'w')
        outputFile.write(Header % (os.path.basename(outputFile.name), time.asctime()))
        outputFile.write(ParamListHeader % (prefix.upper(), prefix.upper(), prefix))
        last = ''
        maxLength = max([len(x) for x in self.paramList.keys()]) + 6
        for (name, node) in self.paramList.ordered_items():
            outputFile.write('    PL_%s' % name.replace(':', '_'))

            if '_BEGIN' in last or name.endswith('_END'):
                outputFile.write('%s = PL_%s' % (' ' * (maxLength - len(name)), last))

            outputFile.write(',\n')
            last = name

        outputFile.write(HeaderBody)
        for (name, node) in self.paramList.ordered_items():
            try:
                name = abbreviate(name)
                if name.endswith('_BEGIN') or name.endswith('_END'):
                    continue
                nodeType = node.get('type', 'NoType')
                if node.tag in ('iocPoint', 'iocEnumBit', 'iocEnumValue'):
                    nodeDir = node.get('dir', 'out')
                    if int(node.get('size', 0)) > 0:
                        dType = DTypeWaveformMap[nodeDir][nodeType]
                    else:
                        dType = DTypeMap[nodeDir][nodeType]

                    paramType = ParamTypeMap[dType]
                    outputFile.write('    {0, %s, "%s"},\n' % (paramType, name))

                else:
                    outputFile.write('    {0, asynParamUndefined, "%s"},\n' % (name))
            except:
                self.log('Error processing %s' % node_to_string(node))
                raise

        outputFile.write(HeaderFooter)
        self.fileList.append(filename)

    def build_ioc_status_update(self, node, cppFile):


        nodeName = node.get('name', '??')

        # first child node should be enumBit
        enumNode = node[0]
        assert(enumNode.tag == 'iocEnum')
        enumBit = enumNode[0]
        assert(enumBit.tag == 'iocEnumBit')
        if enumBit.get('zsv') is not None:
            alarmLevel = "0"
        else:
            alarmLevel = "1"

        cppFile.write('  AdbeStatus %sStatus = status;\n' % nodeName);
        cppFile.write('  if (%s == info.%s) {\n' % (alarmLevel, nodeName))
        self.debugCode(cppFile, '      LOG_DEBUG("setting %s invalid");\n' % nodeName)
        cppFile.write('      %sStatus = ADBE_INVALID;\n' % nodeName)
        cppFile.write('  }\n')

        for child in node[1:]:
            childType = child.get('type', '??')
            childName = child.get('name', '??')
            childSize = int(child.get('size', 0))
            if 'iocPoint' == child.tag and childSize > 0:
                # waveform
                cppFile.write('  index = update_%s_waveform(drv, index, info.%s, %sStatus);\n' % (childType, childName, nodeName))
            elif child.tag in ('iocPoint', 'iocStructure'):
                cppFile.write('  index = update_%s(drv, index, info.%s, %sStatus);\n' % (childType, childName, nodeName))
            elif 'iocEnum' == child.tag:
                cppFile.write('  // bitfields for %s\n' % childName)
                # expect single iocEnum node containing one or more iocEnumBit or iocEnumValue
                for enumNode in child:
                    bitNum = enumNode.get('bit', '0')
                    width = enumNode.get('width', '1')
                    if 'iocEnumBit' == enumNode.tag:
                        cppFile.write('  index = update_bit(drv, index, info.%s, %s, status);\n' % (childName, bitNum))
                    elif 'iocEnumValue' == enumNode.tag:
                        cppFile.write('  index = update_bitfield(drv, index, info.%s, %s, %s, status);\n' % (childName, bitNum, width))
            elif 'iocArray' == child.tag and len(child) > 0:
                # all children same time for arrays
                grandChild = child[0]
                grandChildType = grandChild.get('type', '??')
                self.debugCode(cppFile, '  LOG_DEBUG(" %s %s size = %%d", info.%s.size());\n' % (childType, childName, childName))
                cppFile.write('  for(%s::iterator iter = info.%s.begin(); iter != info.%s.end(); ++iter) {\n' % (childType, childName, childName))
                cppFile.write('    index = update_%s(drv, index, *iter, %sStatus);\n' % (grandChildType, nodeName))
                cppFile.write('  }\n')

    def build_asyn_update_function(self, node, cppFile, hppFile):
        nodeType = node.get('type', '??')
        nodeName = node.get('name', '??')
        nodeStatus = node.get('status', 'false')
        if 'iocArray' == node.tag and 'top' == nodeType:
            cppFile.write('// nodeType %s status %s\n' % (nodeType, nodeStatus))
            cppFile.write('int update_%s(AskapPortDriver *drv, int begin, %s &info, asynStatus status)\n' % (nodeName, nodeName))
            hppFile.write('int update_%s(AskapPortDriver *drv, int begin, askap::adbe::%s &info, asynStatus status);\n' % (nodeName, nodeName))
            cppFile.write('{\n')
            for child in node:
                childType = child.get('type', '??')
                childName = child.get('name', '??')
                cppFile.write('  int index = begin;\n')
                cppFile.write('  for(%s::iterator iter = info.begin(); iter != info.end(); ++iter) {\n' % (nodeName))
                cppFile.write('    index = update_%s(drv, index, *iter, status);\n' % (childType))
                cppFile.write('  }\n')
            cppFile.write('  return index;\n')
            cppFile.write('}\n\n')
        if 'iocStructure' == node.tag and 'direct' != nodeType:
            cppFile.write('// nodeType %s status %s\n' % (nodeType, nodeStatus))
            if 'top' == nodeType:
                cppFile.write('int update_%s(AskapPortDriver *drv, int begin, %s &info, asynStatus status)\n' % (nodeName, nodeName))
                hppFile.write('int update_%s(AskapPortDriver *drv, int begin, askap::adbe::%s &info, asynStatus status);\n' % (nodeName, nodeName))
            else:
                cppFile.write('static int update_%s(AskapPortDriver *drv, int begin, %s &info, asynStatus status)\n' % (nodeName, nodeName))
            cppFile.write('{\n')
            cppFile.write('  int index = begin;\n')
            if 'true' == nodeStatus or 'top' == nodeType:
                cppFile.write('  if (asynDisabled == status || ADBE_NOT_PRESENT == info.status) {\n')
                self.debugCode(cppFile, '      LOG_DEBUG("setting %s disabled");\n' % (nodeName))
                cppFile.write('      status = asynDisabled;\n')
                cppFile.write('  }\n')
                cppFile.write('  else if (ADBE_OK != info.status) {\n')
                self.debugCode(cppFile, '      LOG_DEBUG("setting %s error %%d", info.status);\n' % (nodeName))
                cppFile.write('      status = asynError;\n')
                cppFile.write('  }\n')
            for child in node:
                childType = child.get('type', '??')
                childName = child.get('name', '??')
                childSize = int(child.get('size', 0))
                self.debugCode(cppFile, '  LOG_DEBUG("updating %s.%s @ %%d status %%d", index, status);\n' % (nodeName,childName))

                if 'iocPoint' == child.tag and childSize > 0:
                    # waveform
                    cppFile.write('  index = update_%s_waveform(drv, index, info.%s, status);\n' % (childType, childName))
                elif 'iocEnum' == child.tag:
                    cppFile.write('    // bitfields for %s\n' % childName)
                    if len(child) > 1:
                        cppFile.write('  index = update_uint32(drv, index, info.%s, status);\n' % (childName))
                    # expect single iocEnum node containing one or more iocEnumBit or iocEnumValue
                    for enumNode in child:
                        bitNum = enumNode.get('bit', '0')
                        width = enumNode.get('width', '1')
                        if 'iocEnumBit' == enumNode.tag:
                            cppFile.write('  index = update_bit(drv, index, info.%s, %s, status);\n' % (childName, bitNum))
                        elif 'iocEnumValue' == enumNode.tag:
                            cppFile.write('  index = update_bitfield(drv, index, info.%s, %s, %s, status);\n' % (childName, bitNum, width))
                elif 'iocPoint' == child.tag or 'iocStructure' == child.tag:
                    cppFile.write('  index = update_%s(drv, index, info.%s, status);\n' % (childType, childName))
                elif 'iocArray' == child.tag and len(child) > 0:
                    # all children same time for arrays
                    grandChild = child[0]
                    grandChildType = grandChild.get('type', '??')
                    self.debugCode(cppFile, '  LOG_DEBUG(" %s %s size = %%d", info.%s.size());\n' % (childType, childName, childName))
                    cppFile.write('  for(%s::iterator iter = info.%s.begin(); iter != info.%s.end(); ++iter) {\n' % (childType, childName, childName))
                    cppFile.write('    index = update_%s(drv, index, *iter, status);\n' % (grandChildType))
                    cppFile.write('  }\n')
                elif 'iocStatus' == child.tag:
                    cppFile.write('  index = update_%s(drv, index, info.%s, status);\n' % (childType, childName))
                    self.build_ioc_status_update(child, cppFile)
            cppFile.write('  return index;\n')
            cppFile.write('}\n\n')

    def write_asyn_utils(self, cppFilename):
        headerFilename = os.path.splitext(cppFilename)[0] + '.h'
        define = os.path.basename(os.path.splitext(cppFilename)[0]).upper()

        cppFile = open(cppFilename, 'w')
        cppFile.write(Header % (os.path.basename(cppFile.name), time.asctime()))
        cppFile.write('#include "%s"\n' % headerFilename)
        cppFile.write('#include "%s_version.h"\n' % self._appName)
        cppFile.write('#include "ioclog/Logging.h"\n')
        cppFile.write('CREATE_LOGGER(".asynutils");\n')
        libs = {}
        for libName, file in self.includeFiles:
            if libName is not None:
                libs[libName] = 1
        for lib in libs.keys():
            cppFile.write('using namespace askap::%s;\n' % lib)

        hppFile = open(headerFilename, 'w')
        hppFile.write(Header % (os.path.basename(hppFile.name), time.asctime()))
        hppFile.write('#ifndef %s\n' % define)
        hppFile.write('#define %s\n' % define)
        hppFile.write('#include "asynUtils.h"\n')
        hppFile.write('#include <AskapPortDriver.h>\n')
        for libName, file in self.includeFiles:
            hppFile.write('#include <%s>\n' % os.path.join(libName or '',file))

        for child in self.root:
            if child.get('type', '') == 'asyn':
                continue
            nodeType = child.get('type', '')
            self.build_asyn_update_function(child, cppFile, hppFile)

        hppFile.write('#endif //%s\n' % define)
        self.fileList.append(cppFile.name)
        self.fileList.append(hppFile.name)

    def build_emu_init_function(self, level, prefix, node, cppFile, hppFile):
        nodeName = node.get('name', '??')
        nodeFullName = node.get('fullname', '??')
        nodeType = node.get('type', '??')
        nodeIndex = int(node.get('index', 0))
        paramType = node.get('type', nodeName)
        cppFile.writeIn(level, "// build_emu_init_function node tag %s size %d name %s type %s index %s\n" % (node.tag, len(node), nodeName, nodeType, nodeIndex))
        if 'iocArray' == node.tag:
            lv = chr(ord('i') + level)
            cppFile.writeIn(level, 'for(size_t %s=0; %s < initial_%s.size(); ++%s) {' % (lv, lv, prefix, lv))
            for x,child in enumerate(node):
                childType = child.get('type', '??')
                childName = child.get('name', '??')
                childSize = int(child.get('size', 0))
                self.build_emu_init_function(level+1, prefix + '[%s]' % lv, child, cppFile, hppFile)
            cppFile.writeIn(level, '}\n')
        elif nodeIndex > 1:
            return
        elif len(node) > 0 and nodeType != 'bool' and node.tag not in ('iocEnum'):
            for x,child in enumerate(node):
                childType = child.get('type', '??')
                childName = child.get('name', '??')
                childSize = int(child.get('size', 0))
                if node.tag == 'iocArray':
                    appendName = '[%d]' % x
                else:
                    appendName = '.' + childName
                cppFile.writeIn(level+1, "// loop %d attrib %s\n" % (x, node.attrib))
                self.build_emu_init_function(level+1, prefix + appendName, child, cppFile, hppFile)
        elif nodeIndex > 1:
            return
        else:
            size = int(node.get('size',1))
            limits = {}
            for limitName in ('lolo', 'hihi'):
                limit = node.get(limitName)
                if nodeType not in DefaultValues[limitName]:
                    continue
                if (limit is None or len(limit) == 0):
                    limit = DefaultValues[limitName][nodeType]
                limits[limitName] = limit
                #cppFile.writeIn(level, "// %s lolo %s lo %s hi %s high %s attrib %s\n" % (prefix, lolo, lo, hi, hihi, node.attrib))
                if size > 1 or limit is None:
                    cppFile.writeIn(level, " //%s_%s = %s;\n" % (limitName, prefix, limit))
                else:
                    cppFile.writeIn(level, '%s_%s = %s;\n' % (limitName, prefix, limit))

            if size == 1 and 'hihi' in limits and 'lolo' in limits:
                if 'float' == nodeType:
                    cppFile.writeIn(level, 'initial_%s = %s;\n' % (prefix, (float(limits['hihi']) + float(limits['lolo'])) / 2))
                elif 'string' == nodeType:
                    cppFile.writeIn(level, 'initial_%s = %s;\n' % (prefix, limits['lolo']))
                elif 'bool' == nodeType:
                    cppFile.writeIn(level, 'initial_%s = %s;\n' % (prefix, limits['lolo']))
                else :
                    cppFile.writeIn(level, 'initial_%s = %s;\n' % (prefix, (int(limits['hihi']) + int(limits['lolo'])) / 2))
            else:
                    cppFile.writeIn(level, '//inital_%s = ??;\n')

    def build_emu_update_function(self, node, cppFile, hppFile):
        nodeType = node.get('type', '??')
        nodeName = node.get('name', '??')
        cppFile.write('// build_emu_update_function %s\n' % nodeName)
        nodeStatus = node.get('status')
        if 'iocArray' == node.tag and nodeType == 'top':
            hppFile.write('void emu_%s(askap::adbe::%s *info);\n' \
                    % (nodeName, nodeName))
            cppFile.write('void AdbeEmuUtils::emu_%s(askap::adbe::%s *info)\n' % (nodeName, nodeName))
            cppFile.write('{\n')
            cppFile.write('  %s& low = lolo_%s;\n' % (nodeName, nodeName))
            cppFile.write('  %s& high = hihi_%s;\n' % (nodeName, nodeName))

            for child in node:
                childType = child.get('type', '??')
                childName = child.get('name', '??')
                cppFile.write('  for(%s::iterator iter = info->begin(); iter != info->end(); ++iter) {\n' % (nodeName))
                cppFile.write('    emu_%s(&(*iter), low[0], high[0]);\n' % (childType))
                cppFile.write('  }\n')
            cppFile.write('}\n\n')
        if 'iocStructure' == node.tag and nodeType != 'direct':
            if nodeType == 'top':
                cppFile.write('void AdbeEmuUtils::emu_%s(askap::adbe::%s *info)\n' % (nodeName, nodeName))
                hppFile.write('void emu_%s(askap::adbe::%s *info);\n' \
                    % (nodeName, nodeName))
                cppFile.write('{\n')
                cppFile.write('  %s& low = lolo_%s;\n' % (nodeName, nodeName))
                cppFile.write('  %s& high = hihi_%s;\n' % (nodeName, nodeName))
            else:
                cppFile.write('void AdbeEmuUtils::emu_%s(askap::adbe::%s *info, %s &low, %s &high)\n' % (nodeName, nodeName, nodeName, nodeName))
                hppFile.write('void emu_%s(askap::adbe::%s *info, askap::adbe::%s &low, askap::adbe::%s &high);\n' \
                        % (nodeName, nodeName, nodeName, nodeName))
                cppFile.write('{\n')
            tmpDeclared = False
            if nodeStatus is not None:
                self.debugCode(cppFile, '  LOG_DEBUG("emu setting %s OK");\n' % nodeName)
                cppFile.write('  info->status = ADBE_OK;\n')
            for child in node:
                childType = child.get('type', '??')
                childName = child.get('name', '??')
                childSize = int(child.get('size', 0))
                if 'AdbeStatus' == child.get('lookup'):
                    # ignore status
                    continue
                if 'iocPoint' == child.tag and childSize > 0:
                    # waveform
                    cppFile.write('  emu_%s_waveform(&info->%s, low.%s, high.%s);\n' % (childType, childName, childName, childName))
                elif child.tag == 'iocEnum' and child.get('lookup') is not None and 'int' not in childType:
                    if not tmpDeclared:
                        cppFile.write('  int tmp;\n')
                        tmpDeclared = True
                    cppFile.write('  emu_int(&tmp, low.%s, high.%s);\n' % (childName, childName))
                    cppFile.write('  info->%s = (%s)tmp;\n' % (childName, childType))
                elif child.tag in ('iocPoint', 'iocStructure', 'iocEnum'):
                    cppFile.write('  emu_%s(&info->%s, low.%s, high.%s);\n' % (childType, childName, childName, childName))
                elif 'iocArray' == child.tag and len(child) > 0:
                    # all children same time for arrays
                    grandChild = child[0]
                    grandChildType = grandChild.get('type', '??')
                    cppFile.write('  for(%s::iterator iter = info->%s.begin(); iter != info->%s.end(); ++iter) {\n' % (childType, childName, childName))
                    cppFile.write('    emu_%s(&(*iter), low.%s[0], high.%s[0]);\n' % (grandChildType, childName, childName))
                    cppFile.write('  }\n')
            cppFile.write('}\n\n')

    def write_emu_utils(self, cppFilename, lib=False):
        headerFilename = os.path.splitext(cppFilename)[0] + '.h'
        define = os.path.basename(os.path.splitext(cppFilename)[0]).upper()

        cppFile = CodeWriter(cppFilename, 'w', debugMode=False)
        cppFile.write(Header % (os.path.basename(cppFile.name), time.asctime()))
        if lib:
            cppFile.write('#include <adbe/%s>\n' % os.path.basename(headerFilename))
        else:
            cppFile.write('#include <adbe/%s>\n' % headerFilename)
        cppFile.write('#include <adbe/adbe_private.h>\n')
        cppFile.write('CREATE_LOGGER(".EmuUtils");\n')
        cppFile.write('using namespace askap::adbe;\n')

        hppFile = open(headerFilename, 'w')
        hppFile.write(Header % (os.path.basename(hppFile.name), time.asctime()))
        hppFile.write('#ifndef %s\n' % define)
        hppFile.write('#define %s\n' % define)
        hppFile.write('#include <adbe/AdbeObject.h>\n')
        hppFile.write('#include <adbe/EmuUtils.h>\n')
        for libName, file in self.includeFiles:
            hppFile.write('#include <adbe/%s>\n' % os.path.join(libName or '',file))
        hppFile.write('namespace askap {\n')
        hppFile.write('namespace adbe {\n')
        hppFile.write('void emu_init_limits();\n')

        for child in self.root:
            nodeName = child.get('name', '')
            nodeType = child.get('type', '')
            if nodeType == 'top':
                for limitName in ('lolo', 'hihi', 'initial'):
                    prefix = '%s_%s' %(limitName, child.get('name'))
                    cppFile.write('static %s %s;\n' % (nodeName, prefix))

        for child in self.root:
            nodeName = child.get('name', '')
            nodeType = child.get('type', '')
            if nodeType == 'top':
                hppFile.write('void emu_init_%s(%s &info);\n' % (nodeName, nodeName))
                cppFile.write('void askap::adbe::emu_init_%s(%s &info)\n' % (nodeName, nodeName))
                cppFile.write('{\n')
                cppFile.write('  info = initial_%s;\n' % nodeName)
                cppFile.write('}\n')

        hppFile.write('class AdbeEmuUtils : public EmuUtils\n')
        hppFile.write('{\n')
        hppFile.write('public:\n')
        cppFile.write('void askap::adbe::emu_init_limits()\n')
        cppFile.write('{\n')
        for child in self.root:
            nodeName = child.get('name', '')
            nodeType = child.get('type', '')
            if nodeType == 'top':
                prefix = child.get('name')
                self.build_emu_init_function(0, prefix, child, cppFile, hppFile)
        cppFile.write('}\n')

        for child in self.root:
            nodeType = child.get('type', '')
            self.build_emu_update_function(child, cppFile, hppFile)

        hppFile.write('};\n')
        hppFile.write('} //namespace adbe\n')
        hppFile.write('} //namespace askap\n')
        hppFile.write('#endif //%s\n' % define)
        self.fileList.append(cppFile.name)
        self.fileList.append(hppFile.name)

    def add_monitor_points_xml_group(self, xmlFile, node, desc=None, index=None):
        if node.get('hide') is None:
            fullName = node.get('fullname', '??')
            pvName = node.get('pvname', '??')
            nodeType = node.get('type', '')
            nodeSize = int(node.get('size', 1))
            index = node.get('index', index)
            if desc is not None:
                comment = desc
                nodeComment = node.get('comment')
                if nodeComment is not None and len(nodeComment) > 0 and 'iocEnumBit' != node.tag:
                    comment += ':' + nodeComment
            else:
                comment = node.get('comment', '')
            if node.tag != 'iocEnum' or len(node) > 1:
                xmlFile.write('  <Group name="%s" type="%s">\n' % (pvName, node.tag))
                xmlFile.write('    <comment>%s</comment>\n' % comment.strip(':').replace('&', '&amp;'))
                xmlFile.write('    <name>%s</name>\n' % fullName)
                xmlFile.write('    <pv>%s%s</pv>\n' % (self._dbPrefix, pvName))
                egu = node.get('egu')
                if egu is not None:
                    xmlFile.write('    <egu>%s</egu>\n' % node.get('egu', ''))
                if index is not None:
                    xmlFile.write('    <index>%s</index>\n' % index)
                if node.get('dir', 'out') in ('in'):
                    xmlFile.write('    <type>input</type>\n')
                elif node.tag in ('iocPoint', 'iocEnumBit', 'iocEnumValue'):
                    xmlFile.write('    <type>%s</type>\n' % (nodeType))
                else:
                    xmlFile.write('    <type>label</type>\n')
                xmlFile.write('    <size>%s</size>\n' % (nodeSize))

            if len(node) > 0:
                for child in node:
                    self.add_monitor_points_xml_group(xmlFile, child, comment, index)

            if node.tag != 'iocEnum' or len(node) > 1:
                xmlFile.write('  </Group>\n')

    def write_monitor_points_xml(self, xmlFile, node):
        for child in node:
            self.add_monitor_points_xml_group(xmlFile, child)

    def create_monitor_points_xml_files(self, path):
        controlFilename = os.path.join(path, self._appName + '_control.xml')
        self._monitorPointsXml.append(controlFilename)
        controlFile = open(controlFilename, 'w')
        controlFile.write('<macros>\n')
        for node in self.root:
            if node.get('epicsxml') is None:
                continue
            if needs_resolving(node) or 'iocFunction' == node.tag:
                nodeName = node.get("name", self._appName);
                fileName = os.path.join(path, self._appName + '_' + nodeName + '.xml')
                x = 1
                while fileName in self._monitorPointsXml:
                    fileName = os.path.join(path, self._appName + '_' + nodeName + '%d' % x + '.xml')
                    x += 1
                xmlFile = open(fileName, 'w')
                self._monitorPointsXml.append(fileName)
                xmlFile.write('<macros>\n')
                self.write_monitor_points_xml(xmlFile, node)
                xmlFile.write('</macros>\n')
                self.fileList.append(fileName)
                if 'iocFunction' == node.tag:
                    self.write_monitor_points_xml(controlFile, node)
        controlFile.write('</macros>\n')

    def add_monica_points(self, xmlFile, node, desc=None, index=None):
        numPoints = 0
        if node.get('hide') is None:
            fullName = node.get('fullname', '??')
            pvName = node.get('pvname', '??')
            nodeType = node.get('type', '')
            nodeSize = int(node.get('size', 1))
            index = node.get('index', index)
            if desc is not None:
                comment = desc
                nodeComment = node.get('comment')
                if nodeComment is not None and len(nodeComment) > 0 and 'iocenumbit' != node.tag:
                    comment += ':' + nodeComment
            else:
                comment = node.get('comment', '')

            archive = node.get('archive')
            archiveStr = None
            if 'all' == archive:
                archiveStr = 'All-'
            elif archive is not None:
                seconds = ms_to_seconds(archive)
                if seconds is not None:
                    archiveStr = 'Timer-"%s"' % seconds
            if not archiveStr:
                archiveStr = 'Change-'
            
            if node.tag in ('iocPoint', 'iocEnum') and (self._archiveAll or archive is not None):
                if index is not None:
                    comment += ' %s' % index
                monicaName = ''
                if 'S_' in fullName:
                    monicaName = 'summary.' + fullName.replace('S_','').replace(':val','')
                else:
                    egu = node.get('egu', 'status')
                    monicaName = '$(%s).%s' % (egu, fullName.replace(':', '_'))
                xmlFile.write('$(mp)%-50s ' % abbreviate(monicaName))
                xmlFile.write('%-50s' % ('"$(T) %s" ' % comment.strip(':')))
                xmlFile.write('"" ')
                xmlFile.write('%-10s ' % ('"%s"' % node.get('egu', '')))
                xmlFile.write('ANTENNAS T %-50s' % ('EPICSMonitor-"$1:%s%s" ' % (self._dbPrefix, pvName)))
                prec = int(node.get('prec', '1'))
                if prec == 0 or node.tag == 'iocEnum':
                    xmlFile.write('- - - %s - -\n' % (archiveStr))
                else:
                    xmlFile.write('- NumDecimals-"%s" - %s - -\n' % (prec, archiveStr))

                numPoints += 1

            if len(node) > 0:
                #xmlFile.write('\n#\n# %s\n#\n' % fullName)
                for child in node:
                    numPoints += self.add_monica_points(xmlFile, child, comment, index)

            return numPoints

    def create_monica_config(self, path):
        summaryPoints = 0
        summaryFilename = os.path.join(path, self._appName + '_summary_auto.txt')
        if os.path.exists(summaryFilename):
            os.remove(summaryFilename)
        for node in self.root:
            if 'iocSummary' == node.tag:
                with open(summaryFilename, 'a') as xmlFile:
                    for child in node:
                        summaryPoints += self.add_monica_points(xmlFile, child)
            elif needs_resolving(node) or 'iocFuntion' == node.tag:
                nodeName = node.get("name", self._appName);
                fileName = os.path.join(path, self._appName + '_' + nodeName + '_auto.txt')
                x = 1
                while fileName in self._monitorPointsXml:
                    fileName = os.path.join(path, 'auto_' + self._appName + '_' + nodeName + '%d' % x + '_auto.txt')
                    x += 1
                numPoints = 0
                with open(fileName, 'w') as xmlFile:
                    for child in node:
                        numPoints += self.add_monica_points(xmlFile, child)
                if numPoints > 0:     
                    self._monitorPointsXml.append(fileName)
                    self.fileList.append(fileName)
                else:
                    os.remove(fileName)

        if summaryPoints > 0:     
            self._monitorPointsXml.append(summaryFilename)
            self.fileList.append(summaryFilename)
        elif os.path.exists(summaryFilename):
            os.remove(summaryFilename)

    def rebuild_needed(self, sourceFiles=None):
        rebuild = False
        lastBuildTime = 0

        # check for change
        if os.path.exists(self._resolvedName):
            lastBuildTime = os.path.getmtime(self._resolvedName)
        self.log('checking against last build time of %s...' % (time.ctime(lastBuildTime)))
        for file in sourceFiles + [__file__, 'build.py']:
            if not os.path.exists(file):
                continue
            fileTime = os.path.getmtime(file)
            if fileTime > lastBuildTime:
                self.log('rebuilding due to %s (%s)' % (file, time.ctime(fileTime)))
                rebuild = True

        return rebuild

    def generate_output(self):
        try:
            self.log("rebuild needed")
            for dir in self._srcOutDir, self._dbOutDir:
                if dir is not None and not os.path.exists(dir):
                    os.makedirs(dir)
            indent(self.root)
            self.tree.write(self._resolvedName)
            self.fileList.append(self._resolvedName)
            if self._dbOutDir is not None:
                self.write_to_epics_db(os.path.join(self._dbOutDir, self._filePrefix))
                self.write_asyn_param_list(self._srcOutDir, self._filePrefix)
                self.write_asyn_utils(os.path.join(self._srcOutDir, self._filePrefix + '_asyn_utils.cpp'))
            else:
                self.write_emu_utils(os.path.join(self._srcOutDir, self._filePrefix + '_emu_utils.cc'), lib=True)

            xmlBuildDir = os.path.join(self._srcOutDir, self._filePrefix + '_epicsxml')
            if not os.path.exists(xmlBuildDir):
                os.makedirs(xmlBuildDir)
            self.create_monitor_points_xml_files(xmlBuildDir)
            if self._monicaDir is not None:
                if not os.path.exists(self._monicaDir):
                    os.makedirs(self._monicaDir)
                self.create_monica_config(self._monicaDir)
            return self.fileList

        except:
            self.log('Exception caught, cleaning up')
            for file in self.fileList:
                os.remove(file)
            raise

    def install(self):
        files = glob.glob(os.path.join(self._srcOutDir, self._filePrefix + '_epicsxml', '*.xml'))
        if self._xmlOutDir is not None and len(files) > 0:
            if not os.path.exists(self._xmlOutDir):
                os.makedirs(self._xmlOutDir)
            for f in files:
                self.log('installing %s' % os.path.join(self._xmlOutDir, os.path.basename(f)))
                shutil.copy(f, self._xmlOutDir)
        
    def printNodes(self, node, level):
        #print "printNodes", level, node
        name = node.get('name', '')
        nodeType = node.get('type', '')

        if len(node) > 0:
            #print '  ' * level, level, node.tag, nodeType, name, node.attrib
            self.llog(level, level, node.tag, nodeType, name, node.attrib)
            for x in node:
                self.printNodes(x, level + 1)
        else:
            #print '  ' * level, level, node.tag, name, node.attrib
            self.llog(level, node.tag, name, node.attrib)
