# Some common rules.


# CLEANFILES cannot delete directories, therefore use target clean-generic.
clean-generic:
	-rm -rf ti_files
	-rm -f tca.*
	-rm -f .inslog*
	-rm -f *.log
	-rm -f *.i
	-rm -f *.s
	-rm -f src/*.h
	-rm -f *.hh
	-rm -f *.cc
	-rm -f *.cs_cc
	-rm -f doxygen.cfg
	-rm -rf $(top_builddir)/pure_cache
	-rm -rf docxxhtml
#CLEANFILES += tca.* .inslog* *.cc *.h $(top_builddir)/pure_cache docxxhtml/* *.log docxx_hdrs.names

DISTCLEANFILES=\
      pkgext*\
      lofar_config.*\
      .doxygenrc \
      *.spec \
      *.err

# Rule to delete all files generated by bootstrap.
# This is sometimes needed when switching to another version of autotools.
confclean: pkgclean
pkgclean: distclean
	  -rm -rf $(srcdir)/autom4te.cache
	  -rm -f $(srcdir)/config.*
	  -rm -f $(srcdir)/{configure,aclocal.m4,depcomp,install-sh,ltmain.sh}
	  -rm -f $(srcdir)/{Makefile.in,missing,mkinstalldirs}
	  -rm -f $(srcdir)/{Makefile.common,autoconf_share,lofarconf}

# Make the rpm if possible.
# Note:
# MAKE_RPMS is set by lofar_init and possibly overwritten by lofar_general.
# Older package releases include Makefile.common from $lofar_sharedir
# with the effect that the include is handled by make.
# Newer releases (as of 1-11-2005) include Makefile.common from $top_srcdir
# with the effect that the include is handled by automake.
# To be compatible with older releases, it was decided that the MAKE_RPMS
# should be handled by make, hence the blank before endif. Otherwise
# automake complains about an endif without an if.
 ifeq "$(MAKE_RPMS)" "true"
   rpm: dist @RPM_TARGET@
   $(RPM_TARGET): $(DISTFILES)
	${MAKE} dist
	-mkdir -p $(RPM_DIR)/SRPMS
	-mkdir -p `dirname $(RPM_TARGET)`
	$(RPM_PROG) $(RPM_ARGS) $(RPM_TARBALL)
	@echo Congratulations, $(RPM_TARGET) "(and friends)" should now exist.
 endif
# Put the phony target outside the if, otherwise automake gives
# warnings if a .PHONY is also defined in the Makefile.am.
.PHONY: rpm

# Only preprocess the file.
%.i: %.cc
	$(CXX) -E $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $< > $@
%.i: %.c
	$(CC) -E $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $< > $@

# Only compile (but not assemble) the file.
%.s: %.cc
	$(CXX) -S $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $<
%.s: %.c
	$(CC) -S $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $<


# Rules for preprocessing idl files.
# There should be a corresponding .cc file in the source directory
# including the .cs_cc file.
%.cs_cc: %.idl
	$(IDLCXX) $(IDLFLAGS) $(AM_IDLFLAGS) $<
	echo '#include "$*_c.cc"' >  $*.cs_cc
	echo '#include "$*_s.cc"' >> $*.cs_cc


# Rules for preprocessing Qt sources.
%.moc.cc: %.h
	$(QT_DIR)/bin/moc $< -o $@


# Rule to build all test programs.
test: $(check_PROGRAMS)

# Rule to build and run one or more test programs.
# The programs to build/run must be defined in the PGM variable.
checkrun:
	@if [ "$(PGM)" = "" ] ; then \
	   echo "Error: use as: make (mem)checkrun PGM=testprogram"; \
	 else \
	   curwd=`pwd`; \
	   bcurwd=`basename $$curwd`; \
	   if [ "$$bcurwd" != test ]; then \
	     echo "Error: run (mem)checkrun in test directory"; \
	   else \
	     PGMB=; \
	     PGMT=; \
	     for PGMVAR in $(PGM) ; \
	     do \
	       grep "^ *$${PGMVAR}_SOURCES" $(srcdir)/Makefile.am >& /dev/null; \
	       if [ $$? = 0 ]; then \
	         PGMB="$$PGMB $$PGMVAR"; \
	       fi; \
	       PGMTST=$$PGMVAR; \
	       if [ -f $(srcdir)/$${PGMVAR}.sh ] ; then \
	         PGMTST=$(srcdir)/$${PGMVAR}.sh; \
	       elif [ -f $(srcdir)/$${PGMVAR}_test.sh ] ; then \
	         PGMTST=$(srcdir)/$${PGMVAR}_test.sh; \
	       fi; \
	       PGMT="$$PGMT $$PGMTST"; \
	     done; \
	     echo "make check CHECKTOOL='$(CHECKTOOL)' check_PROGRAMS='$$PGMB' TESTS='$$PGMT'"; \
	     make check CHECKTOOL="$(CHECKTOOL)" check_PROGRAMS="$$PGMB" TESTS="$$PGMT"; \
	   fi \
	 fi

# Rule to run test programs using valgrind's memcheck tool.
memcheck:
	@$(RM) `find . -name "*.valgrind.*"`
	make check CHECKTOOL='valgrind --tool=memcheck --num-callers=50 --leak-check=yes --track-fds=yes --log-file=[PROGNAME].valgrind'
	@vgfils=`find . -name "*.valgrind.*"`; \
	vgfils=`echo $$vgfils`; \
	nrvg=`echo "$$vgfils" | wc -w`; \
	nrvg=`echo $$nrvg`; \
	if [ "$$nrvg" != 0  -a  "$$nrvg" != "" ]; then \
	  echo ''; \
	  echo "memcheck error summary from $$nrvg *.valgrind.* file(s)"; \
	  echo '--------------------------------------------------'; \
	  (grep "ERROR SUMMARY: " `echo $$vgfils` | grep -v " 0 errors ") || echo "No memory check errors"; \
	  (grep "definitely lost: " `echo $$vgfils` | grep -v " 0 bytes ") || echo "No definite memory leaks"; \
	  (grep "possibly lost: " `echo $$vgfils` | grep -v " 0 bytes ") || echo "No possible memory leaks"; \
	  (grep " open file descriptor " `echo $$vgfils` | grep -v "descriptor [012]:") || echo "No file descriptor leaks"; \
	fi

# Rule to build and run memcheck for one or more test programs.
# The programs to build/run must be defined in the PGM variable.
## Combine the statements after the checkrun, otherwise the environment
## variables are gone right after they are defined (because each statement
## is executed in a separate process.
memcheckrun:
	$(RM) `find . -name "*.valgrind.*"`
	make checkrun CHECKTOOL='valgrind --tool=memcheck --num-callers=50 --leak-check=yes --track-fds=yes --log-file=[PROGNAME].valgrind' PGM="$(PGM)"
	@vgfils=`find . -name "*.valgrind.*"`; \
	vgfils=`echo $$vgfils`; \
	nrvg=`echo "$$vgfils" | wc -w`; \
	nrvg=`echo $$nrvg`; \
	if [ "$$nrvg" != 0  -a  "$$nrvg" != "" ]; then \
	  echo ''; \
	  echo "memcheckrun error summary from $$nrvg *.valgrind.* file(s)"; \
	  echo '-----------------------------------------------------'; \
	  (grep "ERROR SUMMARY: " `echo $$vgfils` | grep -v " 0 errors ") || echo "No memory check errors"; \
	  (grep "definitely lost: " `echo $$vgfils` | grep -v " 0 bytes ") || echo "No definite memory leaks"; \
	  (grep "possibly lost: " `echo $$vgfils` | grep -v " 0 bytes ") || echo "No possible memory leaks"; \
	  (grep " open file descriptor " `echo $$vgfils` | grep -v "descriptor [012]:") || echo "No file descriptor leaks"; \
	fi


# Rules for building documentation using doxygen or doc++.
# Default output directory is docxxhtml.
DOCDIR := docxxhtml

doc:
	@if [ "$(lofar_doctool)" = "doxygen" ] ; then \
	  cp $(top_builddir)/.doxygenrc doxygen.cfg ; \
	  projnm=`(cd $(srcdir) && pwd) | sed -e "s%.*/LOFAR/%%"` ; \
	  echo "PROJECT_NAME = $$projnm" >> doxygen.cfg ; \
	  echo "INPUT = $(srcdir)" >> doxygen.cfg ; \
	  echo "RECURSIVE = YES" >> doxygen.cfg ; \
	  echo "HTML_OUTPUT = $(DOCDIR)" >> doxygen.cfg ; \
	  echo "EXCLUDE = $(srcdir)/build $(srcdir)/test $(srcdir)/demo" >> doxygen.cfg; \
          echo "GENERATE_TAGFILE = `basename $$projnm`.tag" >> doxygen.cfg ; \
	  $(DOXYGEN) doxygen.cfg ; \
	else \
	  if [ "$(lofar_doctool)" = "docpp" ] ; then \
	    $(DOCPP) $(DOCPPFLAGS) --dir $(DOCDIR) `find $(srcdir) -name "*.h" -print` ; \
	  else \
	    echo "Error: No documentation tool configured" ; \
	  fi \
	fi

docthis:
	@if [ "$(lofar_doctool)" = "doxygen" ] ; then \
	  cp $(top_builddir)/.doxygenrc doxygen.cfg ; \
	  projnm=`(cd $(srcdir) && pwd) | sed -e "s%.*/LOFAR/%%"` ; \
	  echo "PROJECT_NAME = $$projnm" >> doxygen.cfg ; \
	  echo "INPUT = $(srcdir)/src" >> doxygen.cfg ; \
	  echo "RECURSIVE = NO" >> doxygen.cfg ; \
	  echo "HTML_OUTPUT = $(DOCDIR)" >> doxygen.cfg ; \
	  $(DOXYGEN) doxygen.cfg ; \
	else \
	  if [ "$(lofar_doctool)" = "docpp" ] ; then \
	    $(DOCPP) $(DOCPPFLAGS) --dir $(DOCDIR) $(srcdir)/*.h ; \
	  else \
	    echo "Error: No documentation tool configured" ; \
	  fi \
	fi

#
#
# Target to be able to do a system build.
# By default it does a check, but no install.
WITH_CLEAN=0
WITH_INSTALL=0
WITH_CHECK=1
CHECKTOOL=
build_system:
	@if test 2 -eq $(WITH_CLEAN); then \
	  $(MAKE) distclean ; \
	  ../../lofarconf; \
	fi; \
	if test 1 -eq $(WITH_CLEAN); then \
	  $(MAKE) clean ; \
	fi; \
	$(MAKE); \
	if test 1 -eq $(WITH_CHECK); then \
	  $(MAKE) check CHECKTOOL="$(CHECKTOOL)"; \
	fi; \
	if test 1 -eq $(WITH_INSTALL); then \
	  $(MAKE) install ; \
	fi;

# Show the important make variables.
show:
	@echo "CXX      = $(CXX)";
	@echo "   `$(CXX) --version | head -1`";
	@echo "CPPFLAGS = $(AM_CPPFLAGS) $(CPPFLAGS)";
	@echo "CXXFLAGS = $(AM_CXXFLAGS) $(CXXFLAGS)";
	@echo "LDFLAGS  = $(AM_LDFLAGS) $(LDFLAGS)";
	@echo "LIBS     = $(LIBS)";
	@echo "MPIBIN   = $(MPIBIN)";
	@echo "AIPSPP   = $(AIPSPP)";
	@echo "prefix   = $(prefix)";

help:
	@echo "make targets";
	@echo "------------";
	@echo "show              show important make variables";
	@echo "pgm               build test program pgm (in test directory)";
	@echo "test              build all test programs";
	@echo "check             build, run, and check all test programs";
	@echo "check CHECKTOOL=  check test programs with a checktool (like valgrind)";
	@echo "memcheck          check CHECKTOOL='valgrind --tool=memcheck"
	@echo "                    --num-callers=50 --leak-check=yes --track-fds=yes'"
	@echo "checkrun PGM=     build, run, and check given test program(s)";
	@echo "memcheckrun PGM=  build, run, and memcheck given test program(s)";
	@echo ""
	@echo "file.o            make object file (in src or test directory)";
	@echo "file.i            make preprocessed file";
	@echo "file.s            make assembly file";
	@echo "clean             remove object files, etc."
	@echo "distclean         remove almost everything; requires a new lofarconf";
	@echo "pkgclean          distclean and remove files generated by bootstrap";
	@echo "                    requires a new bootstrap and lofarconf";
	@echo "install           install package in $(prefix)";
	@echo "dist              make a distribution";
	@echo "distcheck         make and check a distribution";
	@echo "rpm               make an rpm";

# Define the default variables to export to the test scripts.
TESTS_ENVIRONMENT = LOFARROOT="$(LOFARROOT)" \
                    lofar_sharedir="$(lofar_sharedir)" \
                    prefix="$(prefix)" \
                    top_srcdir="$(top_srcdir)" \
                    srcdir="$(srcdir)" \
		    CHECKTOOLPROGS="$(CHECKTOOLPROGS)" \
		    MPIBIN="$(MPIBIN)" \
		    AIPSPP="$(AIPSPP)"
